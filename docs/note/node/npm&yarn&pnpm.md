
sidebar:
title: npm、yarn、pnpm区别
date: 2023-12-10

# npm、yarn、pnpm

## npm


v3版本一下采用的是嵌套解构，v3以上采用了尽量扁平解构
v5增加了package-lock.json。


### 嵌套的 node_modules 结构
npm 在早期采用的是嵌套的 node_modules 结构，直接依赖会平铺在 node_modules 下，子依赖嵌套在直接依赖的 node_modules 中。

比如项目依赖了A 和 C，而 A 和 C 依赖了不同版本的 B@1.0 和 B@2.0，node_modules 结构如下：

```text
node_modules
├── A@1.0.0
│   └── node_modules
│       └── B@1.0.0
└── C@1.0.0
    └── node_modules
        └── B@2.0.0
```

如果 D 也依赖 B@1.0，会生成如下的嵌套结构：

```text
node_modules
├── A@1.0.0
│   └── node_modules
│       └── B@1.0.0
├── C@1.0.0
│   └── node_modules
│       └── B@2.0.0
└── D@1.0.0
    └── node_modules
        └── B@1.0.0
```

### 依赖地狱 Dependency Hell

在真实场景下，依赖增多，冗余的包也变多，node_modules 最终会堪比黑洞，很快就能把磁盘占满。而且依赖嵌套的深度也会十分可怕，这个就是依赖地狱。

### 扁平的 node_modules 结构

为了将嵌套的依赖**尽量**打平，避免过深的依赖树和包冗余，npm v3 将子依赖「提升」(hoist)，采用扁平的 node_modules 结构，子依赖会尽量平铺安装在主依赖项所在的目录中。

> 不保证严格打平，只是尽量保证扁平，一些依赖因为版本号的问题还是采用嵌套

```text
node_modules
├── A@1.0.0
├── B@1.0.0
└── C@1.0.0
    └── node_modules
        └── B@2.0.0
```

可以看到 A 的子依赖的 B@1.0 不再放在 A 的 node_modules 下了，而是与 A 同层级。

而 C 依赖的 B@2.0 因为版本号原因还是嵌套在 C 的 node_modules 下。

这样不会造成大量包的重复安装，依赖的层级也不会太深，解决了依赖地狱问题，但也形成了新的问题。


## 幽灵依赖 Phantom dependencies

> 幽灵依赖是指在 package.json 中未定义的依赖，但项目中依然可以正确地被引用到。

比如上方的示例其实我们只安装了 A 和 C：

```text
{
  "dependencies": {
    "A": "^1.0.0",
    "C": "^1.0.0"
  }
}
```

由于 B 在安装时被提升到了和 A 同样的层级，所以在项目中引用 B 还是能正常工作的。

幽灵依赖是由依赖的声明丢失造成的，如果某天某个版本的 A 依赖不再依赖 B 或者 B 的版本发生了变化，那么就会造成依赖缺失或兼容性问题。

### 不确定性 Non-Determinism

> 不确定性是指：同样的 package.json 文件，install 依赖后可能不会得到同样的 node_modules 目录结构。

还是之前的例子，A 依赖 B@1.0，C 依赖 B@2.0，依赖安装后究竟应该提升 B 的 1.0 还是 2.0。

```text
node_modules
├── A@1.0.0
├── B@1.0.0
└── C@1.0.0
    └── node_modules
        └── B@2.0.0

node_modules
├── A@1.0.0
│   └── node_modules
│       └── B@1.0.0
├── B@2.0.0
└── C@1.0.0
```
取决于用户的安装顺序。

如果有 package.json 变更，本地需要删除 node_modules 重新 install，否则可能会导致生产环境与开发环境 node_modules 结构不同，代码无法正常运行。

### 依赖分身 Doppelgangers

假设继续再安装依赖 B@1.0 的 D 模块和依赖 @B2.0 的 E 模块，此时：

* A 和 D 依赖 B@1.0
* C 和 E 依赖 B@2.0

可以看到 B@2.0 会被安装两次，实际上无论提升 B@1.0 还是 B@2.0，都会存在重复版本的 B 被安装，这两个重复安装的 B 就叫 doppelgangers。

而且虽然看起来模块 C 和 E 都依赖 B@2.0，但其实引用的不是同一个 B，假设 B 在导出之前做了一些缓存或者副作用，那么使用者的项目就会因此而出错。




## yarn

采用扁平化 node_modules 结构

### 提升安装速度

> 串行 -> 并行操作  提升安装速度
>
> 缓存机制 -> 缓存在磁盘上，第二次安装提升安装速度

在 npm 中安装依赖时，安装任务是串行的，会按包顺序逐个执行安装，这意味着它会等待一个包完全安装，然后再继续下一个。

为了加快包安装速度，yarn 采用了并行操作，在性能上有显著的提高。而且在缓存机制上，yarn 会将每个包缓存在磁盘上，在下一次安装这个包时，可以脱离网络实现从磁盘离线安装。

### lockfile 解决不确定性 - 保证了依赖安装的确定性

> yarn.lock  -->  根据 package.josn 生成
>
> 记录了依赖，以及依赖的子依赖，依赖的版本，获取地址与验证模块完整性的 hash

即使是不同的安装顺序，相同的依赖关系在任何的环境和容器中，都能得到稳定的 node_modules 目录结构，保证了依赖安装的确定性



## npm & yarn 弊端

采用扁平化的 node_modules 结构 ->

* 扁平化算法消耗更多的性能
    * 扁平化依赖算法复杂，需要**消耗较多的性能**，依赖串行安装还有提速空间
* 依赖分身问题
    * 大量文件需要重复下载，对磁盘空间的利用率不足。（虽然在同一个项目中我不会重复的安装依赖 d 了，但是如果我有100个项目，100个项目都需要用到某个包，那么这个包依然会被下载100次，也就是在磁盘的不同地方写入100次）
* 幽灵依赖问题
    * 扁平化依赖 -》依赖非法访问的问题。项目代码在某些情况下可以在代码中使用没有被定义在 package.json 中的包，这种情况就是我们常说的**幽灵依赖**。


## pnpm

> 从依赖提升和扁平化 -> 依赖管理策略：内容寻址存储

### 依赖管理策略

```text
* 系统的全局 store 中 , 依赖的每个版本只会在系统中安装一次
* 引用项目 node_modules 的依赖时，会通过硬链接与符号链接在全局 store 中找到这个文件。抛弃了扁平化解构，node_modules 下会多出 \.pnpm 目录。
    * 硬链接(Hard link) - 硬链接可以理解为**源文件的副本**，项目里安装的其实是副本，它使得用户可以通过路径引用查找到全局 store 中的源文件，而且这个副本根本不占任何空间。同时，pnpm 会在全局 store 里存储硬链接，不同的项目可以从全局 store 寻找到同一个依赖，大大地节省了磁盘空间
    * 符号链接(Symbolic link) - **也叫软连接**，可以理解为快捷方式，pnpm 可以通过它找到对应磁盘目录下的依赖地址

```


A，B，C 模块的示例，使用 pnpm 安装依赖后 node_modules 结构如下：

```text
<store>/xxx 开头的路径是硬链接，指向全局 store 中安装的依赖。
```

其余的是符号链接，指向依赖的快捷方式。

```text
node_modules
├── .pnpm
│   ├── A@1.0.0
│   │   └── node_modules
│   │       ├── A => <store>/A@1.0.0
│   │       └── B => ../../B@1.0.0
│   ├── B@1.0.0
│   │   └── node_modules
│   │       └── B => <store>/B@1.0.0
│   ├── B@2.0.0
│   │   └── node_modules
│   │       └── B => <store>/B@2.0.0
│   └── C@1.0.0
│       └── node_modules
│           ├── C => <store>/C@1.0.0
│           └── B => ../../B@2.0.0
│
├── A => .pnpm/A@1.0.0/node_modules/A
└── C => .pnpm/C@1.0.0/node_modules/C
```
 

**优点**

* 兼容 node 的依赖解析
* 解决幽灵依赖问题
* 解决依赖分身问题
* 安装速度快
* 节省的磁盘空间多

**缺点**

* 兼容性问题： 不支持软链接的环境中，无法使用 pnpm
* 修改依赖源码可能会出现问题： 依赖源文件是安装在 store 中，调试依赖或 patch-package 给依赖打补丁也不太方便，可能会影响其他项目

## 更多探索 yarn Plug’n’Play...

### Plug’n’Play 简单了解

* 抛弃 node_modules
* 脱离 node 生态



