import { ssrRenderAttrs, ssrRenderStyle } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.cc2b3d55.js";
const __pageData = JSON.parse('{"title":"优化手段","description":"","frontmatter":{"sidebar":null,"group":null,"title":"优化手段","isTimeLine":true,"date":"11-10-2023"},"headers":[],"relativePath":"front/performance/优化手段.md","filePath":"front/performance/优化手段.md","lastUpdated":1701683271000}');
const _sfc_main = { name: "front/performance/优化手段.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="优化手段" tabindex="-1">优化手段 <a class="header-anchor" href="#优化手段" aria-label="Permalink to &quot;优化手段&quot;">​</a></h1><p>一、资源请求过程优化</p><p>浏览器缓存</p><p>强缓存 协商缓存 localstorage缓存 service workers</p><p>减少 DNS 查找次数 配置多个域名 http 改用http2 合并请求 减少资源字节数</p><p>js\\css\\打包压缩，移除注释，删除空格 图片雪碧图、base64内嵌 tree shaking去除无用代码</p><p>采用cdn</p><p>二、首屏渲染优化</p><p>css放在头部、js放在底部 减少首屏加载的资源</p><p>只加载关键的资源 对关键资源进行资源提示（详见资源提示） 其他非关键资源懒加载lazyload</p><p>异步无阻塞加载JS</p><p>defer async 动态创建script</p><p>资源提示（Resource Hints）</p><p>dns-prefetch preconnect prefetch prerender preload</p><p>三、构建优化</p><p>使用预编译 使用 Tree-shaking、Scope hoisting、Code-splitting</p><p>使用Tree-shaking可以减少构建后文件的体积 使用Scope Hoisting可以让代码体积更小并且可以降低代码在运行时的内存开销，同时它的运行速度更快 code-splitting可以打包成多个chunk，以便按需加载资源</p><p>开启gzip 使用CDN加速静态资源加载（加快资源访问速度，而且减少打包体积） 多页面应用提取页面间公共代码，以利用缓存 压缩js\\css\\html，移除注释、空格等，小图片使用base64嵌入减少一次http请求 服务端渲染（SSR） 首屏直出 使用import函数动态导入模块 使用HTTP缓存头</p><p>四、编码优化</p><p>DOM</p><p>减少重绘、回流 减少查询DOM的次数 减少DOM元素个数</p><p>JS</p><p>数据访问速度 减少DOM操作</p><p>缓存已经访问过的元素； 使用DocumentFragment暂存DOM，整理好以后再插入DOM树； 操作className，而不是多次读写style； 避免使用JavaScript修复布局。</p><p>单线程限制</p><p>异步回调 多线程API（Web Worker）</p><p>优化算法，减少运行时间 js动画使用requestAnimationframe函数 对高频触发的事件进行节流或消抖 善于使用事件委托 将渐变或者会动画元素放到单独的绘制层中</p><p>CSS</p><p>减少cssom构建时间(少用通用选择符，多用特定选择符) 开启GPU加速 少用css表达式、少用filter 针对一些场景采用css内联的方式</p><p>图片</p><p>图片格式（webp&gt;png&gt;jpeg、gip） 字体图标代替图片 css绘制图片 使用雪碧图 不要在HTML中缩放图片 使用体积小、可缓存的favicon.ico</p><h2 id="dns解析" tabindex="-1">DNS解析 <a class="header-anchor" href="#dns解析" aria-label="Permalink to &quot;DNS解析&quot;">​</a></h2><p><strong>提前解析DNS</strong></p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">&lt;</span><span style="${ssrRenderStyle({ "color": "#85E89D" })}">link</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}"> </span><span style="${ssrRenderStyle({ "color": "#B392F0" })}">ref</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">=</span><span style="${ssrRenderStyle({ "color": "#9ECBFF" })}">&quot;dns-prefetch&quot;</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}"> </span><span style="${ssrRenderStyle({ "color": "#B392F0" })}">href</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">=</span><span style="${ssrRenderStyle({ "color": "#9ECBFF" })}">&quot;&quot;</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">// 使用X-DNS-Prefetch-Control: on/off响应头来控制预解析的开关</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">&lt;</span><span style="${ssrRenderStyle({ "color": "#85E89D" })}">meta</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}"> </span><span style="${ssrRenderStyle({ "color": "#B392F0" })}">http-equiv</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">=</span><span style="${ssrRenderStyle({ "color": "#9ECBFF" })}">&quot;x-dns-prefetch-control&quot;</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}"> </span><span style="${ssrRenderStyle({ "color": "#B392F0" })}">content</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">=</span><span style="${ssrRenderStyle({ "color": "#9ECBFF" })}">&quot;on/off&quot;</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="${ssrRenderStyle({ "color": "#24292E" })}">&lt;</span><span style="${ssrRenderStyle({ "color": "#22863A" })}">link</span><span style="${ssrRenderStyle({ "color": "#24292E" })}"> </span><span style="${ssrRenderStyle({ "color": "#6F42C1" })}">ref</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">=</span><span style="${ssrRenderStyle({ "color": "#032F62" })}">&quot;dns-prefetch&quot;</span><span style="${ssrRenderStyle({ "color": "#24292E" })}"> </span><span style="${ssrRenderStyle({ "color": "#6F42C1" })}">href</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">=</span><span style="${ssrRenderStyle({ "color": "#032F62" })}">&quot;&quot;</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#24292E" })}">// 使用X-DNS-Prefetch-Control: on/off响应头来控制预解析的开关</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#24292E" })}">&lt;</span><span style="${ssrRenderStyle({ "color": "#22863A" })}">meta</span><span style="${ssrRenderStyle({ "color": "#24292E" })}"> </span><span style="${ssrRenderStyle({ "color": "#6F42C1" })}">http-equiv</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">=</span><span style="${ssrRenderStyle({ "color": "#032F62" })}">&quot;x-dns-prefetch-control&quot;</span><span style="${ssrRenderStyle({ "color": "#24292E" })}"> </span><span style="${ssrRenderStyle({ "color": "#6F42C1" })}">content</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">=</span><span style="${ssrRenderStyle({ "color": "#032F62" })}">&quot;on/off&quot;</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">&gt;</span></span></code></pre></div><hr><h2 id="浏览器发送http请求" tabindex="-1">浏览器发送HTTP请求 <a class="header-anchor" href="#浏览器发送http请求" aria-label="Permalink to &quot;浏览器发送HTTP请求&quot;">​</a></h2><h3 id="减少请求次数" tabindex="-1">减少请求次数 <a class="header-anchor" href="#减少请求次数" aria-label="Permalink to &quot;减少请求次数&quot;">​</a></h3><ul><li>资源合并</li></ul><p><strong>使用打包工具</strong></p><p>使用webpack等工具，对js和css资源进行打包，避免js或css文件过多。<br> 但也要考虑打包文件过大的问题，需要再这之间进行综合考虑。 在SPA中常用的实践是，webpack提取出的公用文件先加载，然后路由相关的文件按需加载。</p><p><strong>精灵图</strong><br> 多个小图合并后的图片。<br> 使用的时候使用background-position进行定位使用。</p><ul><li>缓存</li></ul><p><strong>HTTP Cache（详细解释）</strong></p><p><strong>强缓存</strong></p><p>强缓存的特定是不需要询问服务器，它通过expires和cache-control来实现。cache-control的优先级高于expires，它们都用来表示过期时间，expires是存储时间戳，cache-control使用max-age来表示相对时间。</p><p>cache-control 的no-cache不询问浏览器，直接请求服务器（进行协商缓存）。 而no-store则不是不使用任何缓存策略。 s-maxage只在代理服务器中生效。</p><p>如果资源没有过期，则会直接使用该资源。</p><p><strong>协商缓存</strong><br> 协商缓存是请求服务器 后，服务器来判断是返回新的资源，还是告诉浏览器使用旧的资源。</p><p>服务器每次返回资源会带有Last-Modified时间戳，每次服务器请求带上If-Modified-Since的时间戳，由服务器来判断资源修改时间是否与该时间一致。</p><p>last-modified有个问题是，虽然服务器文件修改时间变了，但是文件内容并没有真正变化</p><p>所有加入了ETag，是由文件内容计算出来的唯一标识。请求的时候会以If-None-Match带上该值，来由服务器判断</p><ul><li><strong>Service Worker Cache</strong></li></ul><p>Memory Cache &amp; Disk Cache</p><p>他们是配合http缓存的。 memory cache命中最快，但是它周期较短，base64的图片，较小的js和css能够有较大几率被写进内存，这没有确定的定论。 其他较大的js、css和图片等会被直接写进硬盘，进行缓存。</p><ul><li><strong>存储</strong></li></ul><p>cookie<br> cookie最大为4k，通常用来存储一些用户登录状态，每次请求，浏览器都会带上相同域名下的cookie</p><p>webStrorage<br> webStorage分为两种，sessionStorage和localStorage，它们的大小在5-10M之间。都是以键值对的方式进行存储的。sessionStorage与localStorage的不同在于生命周期的不同，sessionStorage在tab关闭后，就不再存在了，而localStorage的永久存储，除非主动删除</p><h3 id="缩小请求体积" tabindex="-1">缩小请求体积 <a class="header-anchor" href="#缩小请求体积" aria-label="Permalink to &quot;缩小请求体积&quot;">​</a></h3><p><strong>资源压缩</strong></p><ul><li>Gzip - 可以在响应头content-encoding: gzip中看到</li><li>代码压缩 - 代码压缩工具，删除掉无用的注释、空行和缩减名称等操作来减少文件体积</li><li>图片压缩</li></ul><p><strong>图片选用正确的格式</strong></p><p>JPG 有损压缩、体积小。PNG无损压缩、质量高。在不同的情况用不同的格式有利于优化图片加载速度。 在轮播大图、头像等一般使用JPG，图标、大logo的话一般使用PNG</p><p>PNG<br> 无损格式，压缩率一般，支持透明背景，常用于透明图片或者Icon等。</p><p>JPG<br> 有损格式，压缩率较好，常用于复杂的大图，不支持透明背景。</p><p>SVG<br> 矢量图形，可编程。在各分辨率下不失真，但是渲染复杂图形较消耗性能。常用于简单图形。</p><p>WEBP<br> 无损格式，相较于PNG和JPG来说，压缩率更好，同时支持透明背景。唯一的缺点是兼容性不好。可用于兼容性好的浏览器，用JPG和PNG做回退机制。</p><h2 id="服务器发送http响应" tabindex="-1">服务器发送HTTP响应 <a class="header-anchor" href="#服务器发送http响应" aria-label="Permalink to &quot;服务器发送HTTP响应&quot;">​</a></h2><h3 id="减少响应时间" tabindex="-1">减少响应时间 <a class="header-anchor" href="#减少响应时间" aria-label="Permalink to &quot;减少响应时间&quot;">​</a></h3><p><strong>利用CDN</strong><br> cdn全称content delivery network。它是依靠部署在各地区的边缘服务器，达到用户就近获取内容，降低网络拥塞，提高用户访问速度和命中率的目的。它主要的关键技术是内容存储和分发技术。</p><h3 id="降低页面初始渲染时间" tabindex="-1">降低页面初始渲染时间 <a class="header-anchor" href="#降低页面初始渲染时间" aria-label="Permalink to &quot;降低页面初始渲染时间&quot;">​</a></h3><p><strong>服务器渲染</strong><br> 服务器渲染最大的作用是优化SEO。 同时在性能上也能加快首屏渲染速度，但是这样会对服务器带来一定的压力，所以需要进行综合考量。</p><h2 id="页面渲染" tabindex="-1">页面渲染 <a class="header-anchor" href="#页面渲染" aria-label="Permalink to &quot;页面渲染&quot;">​</a></h2><h3 id="减少阻塞" tabindex="-1">减少阻塞 <a class="header-anchor" href="#减少阻塞" aria-label="Permalink to &quot;减少阻塞&quot;">​</a></h3><p><strong>JS阻塞</strong></p><p>当html解析遇到js会先下载和执行js文件，这是为了防止js操作了dom等情况的发生。但我们作为操作者，可以人为的指定，那些元素可以延迟加载。 为script标签指定 async 或 defer来延迟脚本。</p><p>async表示js不会阻塞，但会在下载完成后立刻执行</p><p>defer则会在下载完成并且整个文档解析完成、DOMContentLoaded事件被触发前开始执行</p><p><strong>CSS阻塞</strong></p><p>css会阻塞html进行渲染，但是为了界面没有任何样式的展现在用户面前，因此我们需要将css提前</p><h3 id="减少渲染次数" tabindex="-1">减少渲染次数 <a class="header-anchor" href="#减少渲染次数" aria-label="Permalink to &quot;减少渲染次数&quot;">​</a></h3><p><strong>避免回流与重绘</strong></p><p><strong>减少渲染节点数量</strong></p><ul><li>懒加载<br> 懒加载包括对图片或者dom元素的加载和渲染</li></ul><p><strong>提高渲染效率</strong></p><ul><li><p>减少dom节点的操作</p><p>浏览器的渲染引擎和js引擎是分离的，可以想象在js引擎和渲染引擎之间进行”跨界交流“并不简单，这个开销很大，所有我们要尽量避免这种操作。</p></li><li><p>利用事件循环和异步更新</p></li></ul></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("front/performance/优化手段.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const ____ = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  ____ as default
};
