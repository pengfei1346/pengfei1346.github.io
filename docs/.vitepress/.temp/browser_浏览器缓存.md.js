import { ssrRenderAttrs } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.cc2b3d55.js";
const __pageData = JSON.parse('{"title":"浏览器的缓存机制","description":"","frontmatter":{"title":"浏览器的缓存机制","date":"2023-11-21T00:00:00.000Z","tags":null},"headers":[],"relativePath":"browser/浏览器缓存.md","filePath":"browser/浏览器缓存.md","lastUpdated":1708417368000}');
const _sfc_main = { name: "browser/浏览器缓存.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="浏览器的缓存机制" tabindex="-1">浏览器的缓存机制 <a class="header-anchor" href="#浏览器的缓存机制" aria-label="Permalink to &quot;浏览器的缓存机制&quot;">​</a></h1><h2 id="认识浏览器缓存" tabindex="-1">认识浏览器缓存 <a class="header-anchor" href="#认识浏览器缓存" aria-label="Permalink to &quot;认识浏览器缓存&quot;">​</a></h2><p>当浏览器请求一个网站时，会加载各种资源，对于一些不经常变动的资源，浏览器会将他们保存在本地内存中，下次访问时直接加载这些资源，提高访问速度。</p><ul><li>disk cache： 就是将资源存储在磁盘中，等待下次访问时不需重新下载，直接从磁盘中读取，它的直接操作对象为CurlCacheManager。（效率比内存缓存慢，但存储容量大，存储时间长）</li><li>memory cache： 就是将资源缓存到内存中，等待下次访问时不需重新下载，直接从内存中读取。（从效率上看它是最快的，从存活时间来看，它是最短的。）</li></ul><p>memory cache disk cache 相同点 只能存储一些派生类资源文件 只能存储一些派生类资源文件 不同点 退出进程时数据会被清除 退出进程时数据不会被清除 存储资源 一般脚本、字体、图片会存在内存当中 一般非脚本会存在内存当中，如css等</p><h2 id="浏览器缓存分类" tabindex="-1">浏览器缓存分类 <a class="header-anchor" href="#浏览器缓存分类" aria-label="Permalink to &quot;浏览器缓存分类&quot;">​</a></h2><ul><li>强缓存</li><li>协商缓存</li></ul><p><strong>浏览器向服务器请求资源时，首先判断是否命中强缓存，然后再判断是否命中协商缓存，都没命中的话就向服务器请求资源。</strong></p><p>即</p><ul><li>1.先看是否命中强缓存，命中🎯的话直接使用缓存</li><li>2.没命中强缓存，则会发送请求到服务器看是否命中🎯协商缓存</li><li>3.如果命中了协商缓存，服务器会返回304告诉浏览器可以使用本地缓存</li><li>4.没命中协商缓存，则服务器会返回新的资源给浏览器</li></ul><h3 id="强缓存-部分header类型-待补充" tabindex="-1">强缓存 - 部分header类型，待补充 <a class="header-anchor" href="#强缓存-部分header类型-待补充" aria-label="Permalink to &quot;强缓存 - 部分header类型，待补充&quot;">​</a></h3><h4 id="expires" tabindex="-1"><strong>Expires</strong> <a class="header-anchor" href="#expires" aria-label="Permalink to &quot;**Expires**&quot;">​</a></h4><p>http1.0 时的规范，值为一个<strong>绝对时间</strong>的 GMT 格式的时间字符串（ Expires:Mon,18 Oct 2066 23:59:59 GMT），代表资源的失效时间</p><p>缺陷：如果服务器和客户端时间存在偏差，会导致缓存混乱。</p><h4 id="cache-control" tabindex="-1"><strong>Cache-Control</strong> <a class="header-anchor" href="#cache-control" aria-label="Permalink to &quot;**Cache-Control**&quot;">​</a></h4><blockquote><p>Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候 Cache-Control 优先级高。</p></blockquote><p>http1.1 时出现的 header 信息，利用该字段的max-age（Cache-Control:max-age=3600）来进行判断，它是一个<strong>相对时间</strong>，其他常用的值。</p><ul><li>no-cache：需要进行协商缓存，发送请求到服务器确认是否使用缓存。</li><li>no-store：禁止使用缓存，每一次都要重新请求数据。</li><li>public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。</li><li>private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。</li></ul><h3 id="协商缓存-部分header类型-待补充" tabindex="-1">协商缓存 - 部分header类型，待补充 <a class="header-anchor" href="#协商缓存-部分header类型-待补充" aria-label="Permalink to &quot;协商缓存 - 部分header类型，待补充&quot;">​</a></h3><p>当强缓存没命中时，浏览器会发送一个请求到服务器，服务器根据 header 中的信息来判断是否命中协商缓存。如果命中，则返回304 ，告诉浏览器资源未更新，可以使用本地缓存。</p><h4 id="last-modify-if-modify-since" tabindex="-1"><strong>Last-Modify/If-Modify-Since</strong> <a class="header-anchor" href="#last-modify-if-modify-since" aria-label="Permalink to &quot;**Last-Modify/If-Modify-Since**&quot;">​</a></h4><ul><li>浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modify（标识该资源的最后修改时间）</li><li>当浏览器再次请求该资源时，<strong>request 的请求头</strong>中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify</li><li>服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。</li><li>如果命中缓存，则返回 304，并且不会返回资源内容，并且不会返回 Last-Modify。</li></ul><p><strong>缺点：</strong></p><ul><li>如果 短时间内资源发生了改变，Last-Modified 并不会发生变化。</li><li>如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的。但是 Last-Modified机制是使用不了缓存的。</li></ul><h4 id="etag-if-none-match" tabindex="-1"><strong>ETag/If-None-Match</strong> <a class="header-anchor" href="#etag-if-none-match" aria-label="Permalink to &quot;**ETag/If-None-Match**&quot;">​</a></h4><blockquote><p>Etag/If-None-Match 返回的是一个校验码。</p><p>Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。</p></blockquote><ul><li><strong>ETag</strong> 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化</li><li>服务器根据浏览器上送的 <strong>If-None-Match</strong> 值来判断是否命中缓存。</li></ul></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("browser/浏览器缓存.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const _____ = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  _____ as default
};
