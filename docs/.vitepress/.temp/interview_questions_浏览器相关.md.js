import { ssrRenderAttrs } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.cc2b3d55.js";
const __pageData = JSON.parse('{"title":"浏览器相关面试题","description":"","frontmatter":{"sidebar":null,"group":null,"title":"浏览器相关面试题","isTimeLine":true,"date":"11-10-2023"},"headers":[],"relativePath":"interview/questions/浏览器相关.md","filePath":"interview/questions/浏览器相关.md","lastUpdated":1708417368000}');
const _sfc_main = { name: "interview/questions/浏览器相关.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h2 id="浏览器相关面试题" tabindex="-1">浏览器相关面试题 <a class="header-anchor" href="#浏览器相关面试题" aria-label="Permalink to &quot;浏览器相关面试题&quot;">​</a></h2><h2 id="输入url发生了什么" tabindex="-1">输入url发生了什么 <a class="header-anchor" href="#输入url发生了什么" aria-label="Permalink to &quot;输入url发生了什么&quot;">​</a></h2><p><a href="/browser/url.html">笔记地址</a></p><h2 id="浏览器是如何解析代码的" tabindex="-1">浏览器是如何解析代码的？ <a class="header-anchor" href="#浏览器是如何解析代码的" aria-label="Permalink to &quot;浏览器是如何解析代码的？&quot;">​</a></h2><p><a href="/browser/浏览器是如何解析代码的.html">笔记地址</a></p><h2 id="domcontentloaded与load的区别" tabindex="-1">DOMContentLoaded与load的区别？ <a class="header-anchor" href="#domcontentloaded与load的区别" aria-label="Permalink to &quot;DOMContentLoaded与load的区别？&quot;">​</a></h2><ul><li>DOMContentLoaded：仅当DOM解析完成后触发，不包括样式表，图片等资源。</li><li>Load：当页面上所有的DOM，样式表，脚本，图片等资源加载完毕事触发。</li></ul><h2 id="浏览器重绘域重排的区别" tabindex="-1">浏览器重绘域重排的区别？ <a class="header-anchor" href="#浏览器重绘域重排的区别" aria-label="Permalink to &quot;浏览器重绘域重排的区别？&quot;">​</a></h2><ul><li>重排： 部分渲染树或整个渲染树需要重新分析且节点尺寸需要重新计算，表现为重新生成布局，重新排列元素</li><li>重绘： 由于节点的几何属性发生改变或样式改变，例如元素背景元素，表现为某些元素的外观被改变</li></ul><blockquote><p>重绘不一定导致重排，但重排一定绘导致重绘</p></blockquote><h3 id="如何触发重绘和重排" tabindex="-1">如何触发重绘和重排？ <a class="header-anchor" href="#如何触发重绘和重排" aria-label="Permalink to &quot;如何触发重绘和重排？&quot;">​</a></h3><p>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p><ul><li>添加、删除、更新DOM节点</li><li>通过display: none隐藏一个DOM节点-触发重排和重绘</li><li>通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化</li><li>移动或者给页面中的DOM节点添加动画</li><li>添加一个样式表，调整样式属性</li><li>用户行为，例如调整窗口大小，改变字号，或者滚动。</li></ul><h3 id="如何避免重绘或重排" tabindex="-1">如何避免重绘或重排？ <a class="header-anchor" href="#如何避免重绘或重排" aria-label="Permalink to &quot;如何避免重绘或重排？&quot;">​</a></h3><ul><li>集中改变样式：比如使用class的方式来集中改变样式</li><li>使用document.createDocumentFragment()：我们可以通过createDocumentFragment创建一个游离于DOM树之外的节点，然后在此节点上批量操作，最后插入DOM树中，因此只触发一次重排</li><li>提升为合成层 将元素提升为合成层有以下优点： <ul><li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li><li>当需要repaint 时，只需要 repaint 本身，不会影响到其他的层</li><li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li><li>提升合成层的最好方式是使用 CSS 的 will-change 属性</li></ul></li></ul><h2 id="为什么js是单线程的" tabindex="-1">为什么JS是单线程的？ <a class="header-anchor" href="#为什么js是单线程的" aria-label="Permalink to &quot;为什么JS是单线程的？&quot;">​</a></h2><p>这主要与JS的用途有关，JS作为浏览器的脚本语言，最初主要是实现用户与浏览器的交互，以及操作DOM。这就决定了它只能是单线程，否则会带来许多复杂的同步问题。 举个例子🌰： 如果JS是多线程的，其中一个线程要修改一个DOM元素，另外一个线程想要删除这个DOM元素，这时候浏览器就不知道该听谁的。所以为了避免复杂性，从一诞生，JavaScript就被设计成单线程。</p><p><strong>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质</strong></p><h2 id="css加载会阻塞dom吗" tabindex="-1">CSS加载会阻塞DOM吗 <a class="header-anchor" href="#css加载会阻塞dom吗" aria-label="Permalink to &quot;CSS加载会阻塞DOM吗&quot;">​</a></h2><blockquote><p>CSS不会阻塞DOM的解析，但会阻塞DOM的渲染</p><p>CSS会阻塞JS执行，但不会阻塞JS文件的下载</p></blockquote><p><strong>CSSOM的作用</strong></p><ul><li>第一个是提供给JavaScript操作样式表的能力</li><li>第二个是为布局树的合成提供基础的样式信息</li><li>这个CSSOM体现在DOM中就是document.styleSheets</li></ul><p>由之前讲到的浏览器渲染流程我们可以看出：</p><ul><li>DOM和CSSOM通常是并行构建的，所以CSS加载不会阻塞DOM的解析</li><li>render树是依赖DOM树和CSSOM树的，所以它必须等到两者都加载完毕才能开始构建渲染，所以CSS加载会阻塞DOM的渲染</li><li>由于JavaScript是可以操作DOM与CSS的，如果在修改这些元素属性同时渲染界面（即JavaScript线程与UI线程同时进行），那么渲染线程前后获得的元素可能就不一致了。所以为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JavaScript线程为互斥的关系</li></ul><p><strong>JS需要等待CSS的下载，这是为什么呢？（CSS阻塞DOM执行）</strong></p><p>如果JS脚本的内容是获取元素的样式，那它就必然依赖CSS。因为浏览器无法感知JS内部到底想干什么，为避免样式获取，就只好等前面所有的样式下载完毕再执行JS。但JS文件与CSS文件下载是并行的，CSS文件会在后面的JS文件执行前先加载执行完毕，所以CSS会阻塞后面JS的执行</p><p><strong>避免白屏，提高CSS的加载速度</strong></p><ul><li>使用CDN（CDN会根据你的网络状况，挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间）</li><li>对CSS进行压缩</li><li>合理使用缓存</li><li>减少http请求数，合并CSS文件</li></ul><h2 id="js会阻塞页面吗" tabindex="-1">JS会阻塞页面吗？ <a class="header-anchor" href="#js会阻塞页面吗" aria-label="Permalink to &quot;JS会阻塞页面吗？&quot;">​</a></h2><blockquote><p>JS会阻塞DOM的解析，因此也就会阻塞页面的加载</p></blockquote><blockquote><p><strong>GUI 渲染线程与 JavaScript 引擎为互斥</strong></p></blockquote><ul><li>当 JavaScript 引擎执行时 GUI 线程会被挂起,GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。</li><li>当浏览器在执行 JavaScript 程序的时候,GUI 渲染线程会被保存在一个队列中,直到 JS 程序执行完成,才会接着执行。</li></ul><p>--------&gt; 因此如果 JS 执行的时间过长,这样就会造成页面的渲染不连贯,导致页面渲染加载阻塞的感觉。</p><h2 id="defer和async的区别" tabindex="-1">defer和async的区别？ <a class="header-anchor" href="#defer和async的区别" aria-label="Permalink to &quot;defer和async的区别？&quot;">​</a></h2><p>笔记 <a href="./script标签中async和defer的区别是什么.html">script标签中async和defer的区别?</a></p><h2 id="浏览器的垃圾回收机制" tabindex="-1">浏览器的垃圾回收机制 <a class="header-anchor" href="#浏览器的垃圾回收机制" aria-label="Permalink to &quot;浏览器的垃圾回收机制&quot;">​</a></h2><p><a href="./../../front/javascript/垃圾回收机制.html">笔记地址</a></p><h2 id="内存泄漏-浏览器中不同类型变量的内存都是何时释放的" tabindex="-1">内存泄漏 &amp; 浏览器中不同类型变量的内存都是何时释放的？ <a class="header-anchor" href="#内存泄漏-浏览器中不同类型变量的内存都是何时释放的" aria-label="Permalink to &quot;内存泄漏 &amp; 浏览器中不同类型变量的内存都是何时释放的？&quot;">​</a></h2><p><a href="./../../front/javascript/内存泄漏.html">笔记地址</a></p><h2 id="浏览器的缓存机制" tabindex="-1">浏览器的缓存机制？ <a class="header-anchor" href="#浏览器的缓存机制" aria-label="Permalink to &quot;浏览器的缓存机制？&quot;">​</a></h2><p><a href="./../../front/javascript/浏览器缓存.html">笔记地址</a></p><h2 id="浏览器的同源策略-跨域" tabindex="-1">浏览器的同源策略？跨域？ <a class="header-anchor" href="#浏览器的同源策略-跨域" aria-label="Permalink to &quot;浏览器的同源策略？跨域？&quot;">​</a></h2><p><a href="./../../front/javascript/浏览器同源策略.html">笔记地址</a></p><h2 id="浏览器的安全问题" tabindex="-1">浏览器的安全问题？ <a class="header-anchor" href="#浏览器的安全问题" aria-label="Permalink to &quot;浏览器的安全问题？&quot;">​</a></h2><p><a href="./../../front/javascript/常见攻击方式.html">笔记地址</a></p></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("interview/questions/浏览器相关.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const _____ = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  _____ as default
};
