import { ssrRenderAttrs } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.cc2b3d55.js";
const __pageData = JSON.parse('{"title":"http","description":"","frontmatter":{"sidebar":null,"group":null,"title":"http","isTimeLine":true,"date":"2023-11-28T00:00:00.000Z"},"headers":[],"relativePath":"internet/http.md","filePath":"internet/http.md","lastUpdated":1722234997000}');
const _sfc_main = { name: "internet/http.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="http" tabindex="-1">http <a class="header-anchor" href="#http" aria-label="Permalink to &quot;http&quot;">​</a></h1><p><a href="https://zhuanlan.zhihu.com/p/488681676" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/488681676</a></p><h2 id="http-历程" tabindex="-1">http 历程 <a class="header-anchor" href="#http-历程" aria-label="Permalink to &quot;http 历程&quot;">​</a></h2><h3 id="http1-0" tabindex="-1">http1.0 <a class="header-anchor" href="#http1-0" aria-label="Permalink to &quot;http1.0&quot;">​</a></h3><p>每次请求都需要重新建立tcp连接，请求完后立即断开与服务器连接，这很大程度造成了性能上的缺陷，http1.0被抱怨最多的就是连接无法复用。</p><h3 id="http1-1" tabindex="-1">http1.1 <a class="header-anchor" href="#http1-1" aria-label="Permalink to &quot;http1.1&quot;">​</a></h3><p>引入了长连接（keep-alive），相较于1.0减少了连接和关闭的延迟，提高了效率，但是若干个请求还是需要串行排队处理，如果一旦某个请求超时，后面的就会被阻塞，也就是常说的线头阻塞。</p><h3 id="http2" tabindex="-1">http2 <a class="header-anchor" href="#http2" aria-label="Permalink to &quot;http2&quot;">​</a></h3><p>1.新的二进制格式传输：二进制即0和1的组合，实现方便健壮，而1.x版本是基于文本，解析存在缺陷</p><p>2.多路复用：一个连接可以有多个请求，且可以混杂在一起根据requestid来区分不同的请求，提高了连接的利用率，降低了延迟</p><p>3.header头部压缩：通讯两方各自缓存了一份 header请求头表，避免了重复的header传输，且缩小了包的体积大小</p><p>4.服务端推送功能：可以服务端主动向客户端push消息</p><h3 id="http-2的多路复用和http-1-x中的长连接复用的区别" tabindex="-1">HTTP/2的多路复用和HTTP/1.X中的长连接复用的区别 <a class="header-anchor" href="#http-2的多路复用和http-1-x中的长连接复用的区别" aria-label="Permalink to &quot;HTTP/2的多路复用和HTTP/1.X中的长连接复用的区别&quot;">​</a></h3><ul><li>HTTP/1.X 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</li><li>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</li><li>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；</li></ul><h3 id="http-1-1与http-2性能对比" tabindex="-1">HTTP/1.1与HTTP/2性能对比 <a class="header-anchor" href="#http-1-1与http-2性能对比" aria-label="Permalink to &quot;HTTP/1.1与HTTP/2性能对比&quot;">​</a></h3><p>HTTP/1.1用了7.41s，而HTTP/2只用了1.47s。HTTP2比HTTP/1.1快了将近5倍。 因为为了加载这张大图，需要请求许多的小图，HTTP/1.1采用的是串行请求，所以速度要比采用并行请求的HTTP/2要慢上许多。</p><h3 id="http3" tabindex="-1">http3 <a class="header-anchor" href="#http3" aria-label="Permalink to &quot;http3&quot;">​</a></h3><p>HTTP/3是基于UDP协议实现的HTTP协议版本，它是在HTTP/2的基础上进一步改进的。HTTP/3的主要优点包括：</p><p>提高了传输速度：由于HTTP/3基于UDP协议，它能够更快速地传输数据，因为UDP协议的头部开销比TCP协议小，并且没有TCP的拥塞控制机制，可以更好地利用带宽。 更好的安全性：HTTP/3使用了TLS协议来保证通信的安全性，TLS协议可以对通信内容进行加密，防止窃听和篡改。 更好的并发性：HTTP/3引入了多路复用技术，可以同时处理多个请求和响应，提高了并发处理能力，减少了延迟和等待时间。 支持QUIC协议：HTTP/3支持使用QUIC协议进行通信，QUIC是一种基于UDP协议的传输层协议，它能够提供更快的传输速度和更好的安全性。</p><h3 id="http-1-0与http-1-1的区别" tabindex="-1">HTTP/1.0与HTTP/1.1的区别 <a class="header-anchor" href="#http-1-0与http-1-1的区别" aria-label="Permalink to &quot;HTTP/1.0与HTTP/1.1的区别&quot;">​</a></h3><p>长连接 HTTP 1.1支持长连接（PersistentConnection）和请求的管道（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection: Keep-Alive； HTTP1.0默认使用短连接，规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪 每个客户也不记录过去的请求。要建立长连接，可以在请求消息中包含Connection: Keep-Alive头域，如果服务器愿意维持这条连接，在响应消息中也会包含一个Connection: Keep-Alive的头域。</p><p>缓存处理</p><p>在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p><ul><li>Expires：浏览器会在指定过期时间内使用本地缓存，指明应该在什么时候认为文档已经过期，从而不再缓存它，时间为格林威治时间GMT。例如: Expires: Thu, 19 Nov 1981 08:52:00 GMT</li><li>Last-Modified：请求对象最后一次的修改时间 用来判断缓存是否过期 通常由文件的时间信息产生</li><li>Date：生成消息的具体时间和日期，即当前的GMT时间。例如:Date: Sun, 17 Mar 2013 08:12:54 GMT</li><li>If-Modified-Since：客户端存取的该资源最后一次修改的时间，用来和服务器端的Last-Modified做比较</li><li>Set-Cookie: 用于把cookie 发送到客户端。例如: Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/</li><li>Pragma:no-cache：客户端使用该头域说明请求资源不能从cache中获取，而必须回源获取。</li></ul><p>带宽优化 HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p><p>错误通知的管理（状态码） 在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p><p>Host头处理 在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p><h3 id="http-2与spdy的区别" tabindex="-1">HTTP/2与SPDY的区别 <a class="header-anchor" href="#http-2与spdy的区别" aria-label="Permalink to &quot;HTTP/2与SPDY的区别&quot;">​</a></h3><p>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</p><p>HTTP2.0 消息头的压缩算法采用 「HPACK」，而非 SPDY 采用的 「DEFLATE」</p><h3 id="http-1-1与http-2的区别" tabindex="-1">HTTP/1.1与HTTP/2的区别 <a class="header-anchor" href="#http-1-1与http-2的区别" aria-label="Permalink to &quot;HTTP/1.1与HTTP/2的区别&quot;">​</a></h3><ul><li>「新的二进制格式」（Binary Format），HTTP1.x解析是基于文本的，基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li><li>「多路复用」（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li><li>「header压缩」，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li><li>「服务端推送」（server push），同SPDY一样，HTTP2.0也具有server push功能。</li></ul><h3 id="https" tabindex="-1">HTTPS <a class="header-anchor" href="#https" aria-label="Permalink to &quot;HTTPS&quot;">​</a></h3><p>HTTPS是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。</p><p><strong>「SSL 协议可分为两层：」</strong></p><ul><li>SSL 记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。</li><li>SSL 握手协议（SSL Handshake Protocol），它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</li></ul><p><strong>「HTTPS的优点」</strong></p><ul><li>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。</li><li>HTTPS 协议是由SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。</li><li>HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li></ul><p><strong>「HTTPS的缺点」</strong></p><ul><li>HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近。</li><li>HTTPS 连接缓存不如 HTTP 高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。</li><li>HTTPS 协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。</li><li>SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。</li><li>部署 HTTPS 后，因为 HTTPS 协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。</li><li>HTTPS 协议的加密范围也比较有限。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。</li></ul><h3 id="与http的区别" tabindex="-1">与HTTP的区别 <a class="header-anchor" href="#与http的区别" aria-label="Permalink to &quot;与HTTP的区别&quot;">​</a></h3><ul><li>HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</li><li>HTTP与HTTPS的连接方式不同，端口也不同，HTTP端口用的是80，HTTPS端口用的是443。</li><li>HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</li><li>HTTPS协议需要申请证书，一般免费的证书很少。</li></ul><hr><h3 id="http状态码" tabindex="-1">HTTP状态码 <a class="header-anchor" href="#http状态码" aria-label="Permalink to &quot;HTTP状态码&quot;">​</a></h3><p>1XX系列：指定客户端应相应的某些动作，代表请求已被接受，需要继续处理。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。</p><p>2XX系列：代表请求已成功被服务器接收、理解、并接受。这系列中最常见的有200、201状态码。</p><p>200状态码：表示请求已成功，请求所希望的响应头或数据体将随此响应返回</p><p>201状态码：表示请求成功并且服务器创建了新的资源，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’</p><p>202状态码：服务器已接受请求，但尚未处理</p><p>3XX系列：代表需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。这系列中最常见的有301、302状态码。</p><p>301状态码：被请求的资源已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。301永久永久永久</p><p>302状态码：请求的资源临时从不同的URI响应请求，但请求者应继续使用原有位置来进行以后的请求</p><p>304状态码:自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应(称为 If-Modified-Since HTTP 标头)。</p><p>4XX系列：表示请求错误。代表了客户端看起来可能发生了错误，妨碍了服务器的处理。常见有：401、404状态码。</p><p>401状态码：请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</p><p>403状态码：服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。</p><p>404状态码：请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</p><p>5xx系列：代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。常见有500、503状态码。</p><p>500状态码：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</p><p>502和504的区别</p><p>502 bad gateway 顾名思义 网关错误 后端服务器tomcat没有起来，应用服务的问题（前提是接入层7层正常的情况下）。</p><p>应用服务问题一种是应用本身问题；另一种是因为依赖服务问题比如依赖服务RT高，依赖的服务有大的读取（mysql慢查，http等），以至于调用方超过超时read时间；服务集群压力大时，也会出现502超时（502理解为不可响应或响应不过来，其实还是不可响应）。</p><p>504 gateway time-out 顾名思义 网关超时 一般计算机中的超时就是配置错了，此处一般指nginx做反向代理服务器时，所连接的服务器tomcat无响应导致的。</p><p>503状态码：由于临时的服务器维护或者过载，服务器当前无法处理请求。通常，这个是暂时状态，一段时间会恢复</p><h3 id="header-解释-示例" tabindex="-1">Header 解释 示例 <a class="header-anchor" href="#header-解释-示例" aria-label="Permalink to &quot;Header 解释 示例&quot;">​</a></h3><p>Accept 指定客户端能够接收的内容类型 Accept: text/plain, text/html,application/json</p><p>Accept-Charset 浏览器可以接受的字符编码集。 Accept-Charset: iso-8859-5</p><p>Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型。 Accept-Encoding: compress, gzip</p><p>Accept-Language 浏览器可接受的语言 Accept-Language: en,zh</p><p>Accept-Ranges 可以请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes</p><p>Authorization HTTP授权的授权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</p><p>Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache</p><p>Connection 表示是否需要持久连接。keep-alive（HTTP 1.1默认进行持久连接） Connection: close（1.0）</p><p>Cookie HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 Cookie: $Version=1; Skin=new;</p><p>Content-Length 请求的内容长度 Content-Length: 348</p><p>Content-Type 请求的与实体对应的MIME信息 Content-Type: application/x-www-form-urlencoded</p><p>Date 请求发送的日期和时间 Date: Tue, 15 Nov 2010 08:12:31 GMT</p><p>Expect 请求的特定的服务器行为 Expect: 100-continue</p><p>From 发出请求的用户的Email From: <a href="mailto:user@email.com" target="_blank" rel="noreferrer">user@email.com</a></p><p>Host 指定请求的服务器的域名和端口号 Host: www.zcmhi.com</p><p>If-Match 只有请求内容与实体相匹配才有效 If-Match: “737060cd8c284d8af7ad3082f209582d”</p><p>If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</p><p>If-None-Match 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 If-None-Match: “737060cd8c284d8af7ad3082f209582d”</p><p>If-Range 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag If-Range: “737060cd8c284d8af7ad3082f209582d”</p><p>If-Unmodified-Since 只在实体在指定时间之后未被修改才请求成功 If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</p><p>Max-Forwards 限制信息通过代理和网关传送的时间 Max-Forwards: 10</p><p>Pragma 用来包含实现特定的指令 Pragma: no-cache</p><p>Proxy-Authorization 连接到代理的授权证书 Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</p><p>Range 只请求实体的一部分，指定范围 Range: bytes=500-999</p><p>Referer 先前网页的地址，当前请求网页紧随其后,即来路 Referer: <a href="http://www.zcmhi.com/archives" target="_blank" rel="noreferrer">http://www.zcmhi.com/archives</a>...</p><p>TE 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 TE: trailers,deflate;q=0.5</p><p>Upgrade 向服务器指定某种传输协议以便服务器进行转换（如果支持） Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</p><p>User-Agent User-Agent的内容包含发出请求的用户信息 User-Agent: Mozilla/5.0 (Linux; X11)</p><p>Via 通知中间网关或代理服务器地址，通信协议 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</p><p>Warning 关于消息实体的警告信息 Warn: 199 Miscellaneous warning</p></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("internet/http.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const http = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  http as default
};
