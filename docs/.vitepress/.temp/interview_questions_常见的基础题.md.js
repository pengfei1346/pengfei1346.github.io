import { ssrRenderAttrs, ssrRenderStyle } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.cc2b3d55.js";
const __pageData = JSON.parse('{"title":"常见的基础题","description":"","frontmatter":{"isTimeLine":true,"title":"常见的基础题","date":"2021-11-21T00:00:00.000Z","tags":["面试"]},"headers":[],"relativePath":"interview/questions/常见的基础题.md","filePath":"interview/questions/常见的基础题.md","lastUpdated":1708996912000}');
const _sfc_main = { name: "interview/questions/常见的基础题.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><p><a href="https://juejin.cn/post/7255595259014201404" target="_blank" rel="noreferrer">https://juejin.cn/post/7255595259014201404</a></p><h1 id="常见的基础题" tabindex="-1">常见的基础题 <a class="header-anchor" href="#常见的基础题" aria-label="Permalink to &quot;常见的基础题&quot;">​</a></h1><h2 id="常见的基础题-1" tabindex="-1">常见的基础题 <a class="header-anchor" href="#常见的基础题-1" aria-label="Permalink to &quot;常见的基础题&quot;">​</a></h2><h3 id="、new-object-和object-create-创建对象的区别" tabindex="-1">{} 、new Object()和Object.create()创建对象的区别 <a class="header-anchor" href="#、new-object-和object-create-创建对象的区别" aria-label="Permalink to &quot;{} 、new Object()和Object.create()创建对象的区别&quot;">​</a></h3><p><strong>new Object()</strong></p><blockquote><p>new 创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p></blockquote><p>new 关键字会进行如下的操作</p><ul><li>创建一个空的简单JavaScript对象（即{}）；</li><li>链接该对象（即设置该对象的构造函数）到另一个对象 ；</li><li>将步骤1新创建的对象作为this的上下文 ；</li><li>如果该函数没有返回对象，则返回this。</li><li>new会创建一个新对象，并且这个新对象继承构造函数的prototype，也就是说创建的实例的proto指向构造函数的prototype</li><li>new Object()会创建一个实例，该实例的proto指向Object的prototype</li></ul><p><strong>Object.create</strong></p><blockquote><p>MDN官方定义： Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。 换个比较容易理解的说法：将现有的对象指定为原型proto，及其属性propertiesObject去创建一个新的对象。</p></blockquote><p>Object.create接受两个参数，即object.create(proto, propertiesObject)</p><ul><li>proto，现有的对象，即新对象的原型对象（新创建的对象proto将指向该对象）。<strong>如果proto 为null，那么创建出来的对象是一个{}并且没有原型</strong></li><li>propertiesObject，可选，给新对象添加新属性以及描述器。<strong>如果没有指定即创建一个{}，有原型也有继承Object.prototype上的方法</strong>。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="${ssrRenderStyle({ "color": "#F97583" })}">function</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}"> </span><span style="${ssrRenderStyle({ "color": "#B392F0" })}">myCreate</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">(</span><span style="${ssrRenderStyle({ "color": "#FFAB70" })}">proto</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">,</span><span style="${ssrRenderStyle({ "color": "#FFAB70" })}">properties</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">){</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">    </span><span style="${ssrRenderStyle({ "color": "#6A737D" })}">//新对象</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">    </span><span style="${ssrRenderStyle({ "color": "#F97583" })}">var</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}"> </span><span style="${ssrRenderStyle({ "color": "#B392F0" })}">fn</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}"> </span><span style="${ssrRenderStyle({ "color": "#F97583" })}">=</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}"> </span><span style="${ssrRenderStyle({ "color": "#F97583" })}">function</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">() { };</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">    </span><span style="${ssrRenderStyle({ "color": "#79B8FF" })}">fn</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">.</span><span style="${ssrRenderStyle({ "color": "#79B8FF" })}">prototype</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}"> </span><span style="${ssrRenderStyle({ "color": "#F97583" })}">=</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}"> proto;</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">    </span><span style="${ssrRenderStyle({ "color": "#F97583" })}">if</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">(properties){</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">        </span><span style="${ssrRenderStyle({ "color": "#6A737D" })}">//defineProperties 在新对象上定义新的属性或修改现有属性</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">        Object.</span><span style="${ssrRenderStyle({ "color": "#B392F0" })}">defineProperties</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">(fn, properties)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">    }</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">    </span><span style="${ssrRenderStyle({ "color": "#F97583" })}">return</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}"> </span><span style="${ssrRenderStyle({ "color": "#F97583" })}">new</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}"> </span><span style="${ssrRenderStyle({ "color": "#B392F0" })}">fn</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">();</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="${ssrRenderStyle({ "color": "#D73A49" })}">function</span><span style="${ssrRenderStyle({ "color": "#24292E" })}"> </span><span style="${ssrRenderStyle({ "color": "#6F42C1" })}">myCreate</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">(</span><span style="${ssrRenderStyle({ "color": "#E36209" })}">proto</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">,</span><span style="${ssrRenderStyle({ "color": "#E36209" })}">properties</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">){</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#24292E" })}">    </span><span style="${ssrRenderStyle({ "color": "#6A737D" })}">//新对象</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#24292E" })}">    </span><span style="${ssrRenderStyle({ "color": "#D73A49" })}">var</span><span style="${ssrRenderStyle({ "color": "#24292E" })}"> </span><span style="${ssrRenderStyle({ "color": "#6F42C1" })}">fn</span><span style="${ssrRenderStyle({ "color": "#24292E" })}"> </span><span style="${ssrRenderStyle({ "color": "#D73A49" })}">=</span><span style="${ssrRenderStyle({ "color": "#24292E" })}"> </span><span style="${ssrRenderStyle({ "color": "#D73A49" })}">function</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">() { };</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#24292E" })}">    </span><span style="${ssrRenderStyle({ "color": "#005CC5" })}">fn</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">.</span><span style="${ssrRenderStyle({ "color": "#005CC5" })}">prototype</span><span style="${ssrRenderStyle({ "color": "#24292E" })}"> </span><span style="${ssrRenderStyle({ "color": "#D73A49" })}">=</span><span style="${ssrRenderStyle({ "color": "#24292E" })}"> proto;</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#24292E" })}">    </span><span style="${ssrRenderStyle({ "color": "#D73A49" })}">if</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">(properties){</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#24292E" })}">        </span><span style="${ssrRenderStyle({ "color": "#6A737D" })}">//defineProperties 在新对象上定义新的属性或修改现有属性</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#24292E" })}">        Object.</span><span style="${ssrRenderStyle({ "color": "#6F42C1" })}">defineProperties</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">(fn, properties)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#24292E" })}">    }</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#24292E" })}">    </span><span style="${ssrRenderStyle({ "color": "#D73A49" })}">return</span><span style="${ssrRenderStyle({ "color": "#24292E" })}"> </span><span style="${ssrRenderStyle({ "color": "#D73A49" })}">new</span><span style="${ssrRenderStyle({ "color": "#24292E" })}"> </span><span style="${ssrRenderStyle({ "color": "#6F42C1" })}">fn</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">();</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#24292E" })}">}</span></span></code></pre></div><p>{} 等价于 new Object()</p><p><strong>共同点</strong></p><p>两者都是创建对象的方式</p><p><strong>不同点</strong></p><ul><li>1.创建空对象的不同 <ul><li>1.1 new Object(null),创建的是空对象，在该对象上有继承原型链的方法和属性；</li><li>1.2 Object.creat(null),创建的是空对象，在该对象上没有继承原型链的方法和属性；</li></ul></li><li>1.创建实例的区别 <ul><li>2.1 使用 new Person() 来创建Person构造函数的新实例，</li><li>2.2 使用 Object.create(Person.prototype) 来创建Person构造函数的新实例，</li></ul></li></ul><h3 id="什么是盒模型" tabindex="-1">什么是盒模型? <a class="header-anchor" href="#什么是盒模型" aria-label="Permalink to &quot;什么是盒模型?&quot;">​</a></h3><p>盒模型(Box Model)用来设定一个元素在网页布局中如何显示,盒模型组成包含内容(content)、内边距(padding)、边框(border)和外边距( margin)。通过盒模型可以精确控制一个元素占用的空间和位置。</p><h3 id="什么是bfc-bfc有什么特点" tabindex="-1">什么是BFC?BFC有什么特点? <a class="header-anchor" href="#什么是bfc-bfc有什么特点" aria-label="Permalink to &quot;什么是BFC?BFC有什么特点?&quot;">​</a></h3><p>BFC指块格式化上下文(Block Formatting Context),它具有如下特点:</p><p>BFC在页面中是一个隔离的布局环境,内外元素互不影响 BFC垂直方向的距离由margin决定,属于同一个BFC的相邻Box垂直外边距会发生重叠 BFC区域不会与浮动元素区域重叠 BFC是一个包含块,可以包含浮动元素 计算BFC高度时,浮动元素也会参与计算</p><p>利用BFC可以解决浮动元素带来的问题,也可以避免margin重叠等布局问题。</p><h3 id="html中事件的冒泡和捕获过程是什么-如何只执行其中一种" tabindex="-1">html中事件的冒泡和捕获过程是什么?如何只执行其中一种? <a class="header-anchor" href="#html中事件的冒泡和捕获过程是什么-如何只执行其中一种" aria-label="Permalink to &quot;html中事件的冒泡和捕获过程是什么?如何只执行其中一种?&quot;">​</a></h3><p>冒泡和捕获描述了事件传播的两个阶段:</p><p>冒泡:事件从触发元素向上传播到DOM树的最上级节点。 捕获:事件从最上级节点往下传播到实际触发事件的节点。</p><p>可以通过addEventListener的第三个参数配置true或者false,来指定只使用事件捕获或事件冒泡阶段:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="${ssrRenderStyle({ "color": "#6A737D" })}">// 只使用捕获阶段</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">ele.</span><span style="${ssrRenderStyle({ "color": "#B392F0" })}">addEventListener</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">(eventName, fn, </span><span style="${ssrRenderStyle({ "color": "#79B8FF" })}">true</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">)</span></span>
<span class="line"></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#6A737D" })}">// 只使用冒泡阶段</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">ele.</span><span style="${ssrRenderStyle({ "color": "#B392F0" })}">addEventListener</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">(eventName, fn, </span><span style="${ssrRenderStyle({ "color": "#79B8FF" })}">false</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="${ssrRenderStyle({ "color": "#6A737D" })}">// 只使用捕获阶段</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#24292E" })}">ele.</span><span style="${ssrRenderStyle({ "color": "#6F42C1" })}">addEventListener</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">(eventName, fn, </span><span style="${ssrRenderStyle({ "color": "#005CC5" })}">true</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">)</span></span>
<span class="line"></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#6A737D" })}">// 只使用冒泡阶段</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#24292E" })}">ele.</span><span style="${ssrRenderStyle({ "color": "#6F42C1" })}">addEventListener</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">(eventName, fn, </span><span style="${ssrRenderStyle({ "color": "#005CC5" })}">false</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">)</span></span></code></pre></div><h3 id="你了解shadow-dom吗-它在什么场景下会使用" tabindex="-1">你了解shadow dom吗?它在什么场景下会使用? <a class="header-anchor" href="#你了解shadow-dom吗-它在什么场景下会使用" aria-label="Permalink to &quot;你了解shadow dom吗?它在什么场景下会使用?&quot;">​</a></h3><p>Shadow DOM可以将一个DOMsubtree封装到一个组件内部,实现组件的封装与隔离。组件内部的DOM改变只会影响组件内部,不会影响页面其他部分,有利于实现组件的封装。 常见的使用场景:</p><p>组件封装:组件内部的模板、样式实现跟外部页面的隔离 Encapsulate styles: 使样式只应用在shadow DOM内而不外泄 Simpler scoping: shadow DOM形成了一个代码封装和作用域隔离的容器</p><p>利用Web Components可以封装独立的组件逻辑,实现可复用、可组合的组件系统,对组件化开发很有意义。</p><h3 id="如何实现资源的预加载" tabindex="-1">如何实现资源的预加载? <a class="header-anchor" href="#如何实现资源的预加载" aria-label="Permalink to &quot;如何实现资源的预加载?&quot;">​</a></h3><p>实现资源预加载常用的技术主要有两种:</p><p>使用标签,设置rel=&quot;preload&quot;可以让浏览器提前加载该资源,语法如:</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">&lt;</span><span style="${ssrRenderStyle({ "color": "#85E89D" })}">link</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}"> </span><span style="${ssrRenderStyle({ "color": "#B392F0" })}">rel</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">=</span><span style="${ssrRenderStyle({ "color": "#9ECBFF" })}">&quot;preload&quot;</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}"> </span><span style="${ssrRenderStyle({ "color": "#B392F0" })}">href</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">=</span><span style="${ssrRenderStyle({ "color": "#9ECBFF" })}">&quot;image.png&quot;</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}"> </span><span style="${ssrRenderStyle({ "color": "#B392F0" })}">as</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">=</span><span style="${ssrRenderStyle({ "color": "#9ECBFF" })}">&quot;image&quot;</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#24292E" })}">&lt;</span><span style="${ssrRenderStyle({ "color": "#22863A" })}">link</span><span style="${ssrRenderStyle({ "color": "#24292E" })}"> </span><span style="${ssrRenderStyle({ "color": "#6F42C1" })}">rel</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">=</span><span style="${ssrRenderStyle({ "color": "#032F62" })}">&quot;preload&quot;</span><span style="${ssrRenderStyle({ "color": "#24292E" })}"> </span><span style="${ssrRenderStyle({ "color": "#6F42C1" })}">href</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">=</span><span style="${ssrRenderStyle({ "color": "#032F62" })}">&quot;image.png&quot;</span><span style="${ssrRenderStyle({ "color": "#24292E" })}"> </span><span style="${ssrRenderStyle({ "color": "#6F42C1" })}">as</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">=</span><span style="${ssrRenderStyle({ "color": "#032F62" })}">&quot;image&quot;</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">&gt;</span></span></code></pre></div><p>使用HTTP头部的Link字段实现预加载,格式如:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="${ssrRenderStyle({ "color": "#B392F0" })}">Link</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">: </span><span style="${ssrRenderStyle({ "color": "#F97583" })}">&lt;/</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">assets</span><span style="${ssrRenderStyle({ "color": "#F97583" })}">/</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">script.js</span><span style="${ssrRenderStyle({ "color": "#F97583" })}">&gt;</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">;rel </span><span style="${ssrRenderStyle({ "color": "#F97583" })}">=</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}"> preload;</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#F97583" })}">as</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}"> = </span><span style="${ssrRenderStyle({ "color": "#B392F0" })}">script</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="${ssrRenderStyle({ "color": "#6F42C1" })}">Link</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">: </span><span style="${ssrRenderStyle({ "color": "#D73A49" })}">&lt;/</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#24292E" })}">assets</span><span style="${ssrRenderStyle({ "color": "#D73A49" })}">/</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">script.js</span><span style="${ssrRenderStyle({ "color": "#D73A49" })}">&gt;</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#24292E" })}">;rel </span><span style="${ssrRenderStyle({ "color": "#D73A49" })}">=</span><span style="${ssrRenderStyle({ "color": "#24292E" })}"> preload;</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#D73A49" })}">as</span><span style="${ssrRenderStyle({ "color": "#24292E" })}"> = </span><span style="${ssrRenderStyle({ "color": "#6F42C1" })}">script</span></span></code></pre></div><p>预加载让浏览器提前请求资源文件,对于需要快速使用的资源可以缩短加载时间,改善用户体验。需要注意,过度预加载会消耗带宽和设备能力。</p><h3 id="css的几种引入方式及其权重-为什么避免过多使用style" tabindex="-1">CSS的几种引入方式及其权重?为什么避免过多使用style? <a class="header-anchor" href="#css的几种引入方式及其权重-为什么避免过多使用style" aria-label="Permalink to &quot;CSS的几种引入方式及其权重?为什么避免过多使用style?&quot;">​</a></h3><p>CSS的引入方式主要有:</p><p>行内样式:在标签style属性中定义 内嵌样式:在HTML文档头部使用style定义 外链样式:通过link标签引入外部CSS文件</p><p><strong>优先级从高到低依次是:行内样式 &gt; 内嵌样式 &gt; 外链样式。</strong></p><p><strong>选择器权重:</strong> !important(10000)&gt;行内(1000)&gt;id(100)&gt;类(10)&gt;标签(1)&gt;通配符(0)</p><p><strong>避免过多使用style的原因:</strong></p><p>style标签在渲染时会阻塞页面加载 过多样式混杂在HTML中,导致内容不够语义化 内联样式优先级高可能会导致样式冲突问题 编写CSS较多时维护困难</p><p>所以推荐使用外链的独立CSS文件进行样式管理。</p><h3 id="什么是闭包" tabindex="-1">什么是闭包? <a class="header-anchor" href="#什么是闭包" aria-label="Permalink to &quot;什么是闭包?&quot;">​</a></h3><p>闭包(Closure)是可以访问另一个函数内部变量的函数。闭包可以让一个函数保持对原始定义作用域的引用,所以使得这个函数可以继续访问定义函数的变量。 产生闭包的条件是:</p><p>必须有一个内嵌函数 内嵌函数必须引用上外层函数的变量 外层函数返回内嵌函数</p><p>然后内嵌函数就拥有了外层函数作用域的访问权,形成了闭包。</p><h3 id="什么是副作用-什么是纯函数" tabindex="-1">什么是副作用?什么是纯函数? <a class="header-anchor" href="#什么是副作用-什么是纯函数" aria-label="Permalink to &quot;什么是副作用?什么是纯函数?&quot;">​</a></h3><p>副作用指函数执行过程对函数外部可观察的状态产生的影响,如修改全局变量、修改参数、打印日志等都是副作用。 纯函数是无副作用的函数,它具有以下特点:</p><p>不修改函数外部状态 相同的输入总是得到相同的输出 不依赖外部状态、只依赖输入参数 没有可观察的副作用</p><p>纯函数可以避免外部状态被修改,更易于测试和理解。</p><h3 id="set、map、weakset、weakmap的区别是什么" tabindex="-1">set、map、weakSet、weakMap的区别是什么? <a class="header-anchor" href="#set、map、weakset、weakmap的区别是什么" aria-label="Permalink to &quot;set、map、weakSet、weakMap的区别是什么?&quot;">​</a></h3><p>Set是普通集合,只能包含值。 WeakSet集合只能包含对象,里面的对象是一个个弱引用。 Map是键值对集合,可以包含任何类型的键和值。 WeakMap的键名只能是对象,值可以是任意类型,键名指向键值也是弱引用。</p><p>区别主要在于WeakSet和WeakMap的引用为弱引用,如果没有其他引用链会释放对象,可以用来防止内存泄漏。后两者只能使用对象作为键名也是为了利用这个特点。</p><h3 id="void-0的作用是什么" tabindex="-1">void 0的作用是什么? <a class="header-anchor" href="#void-0的作用是什么" aria-label="Permalink to &quot;void 0的作用是什么?&quot;">​</a></h3><p>void 0主要的作用是获取undefined的值。在全局作用域中undefined是可以被重写的,为了获取确定为undefined的值,使用void 0是一个好习惯。 例如,下面的赋值可以改变undefined的值:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="${ssrRenderStyle({ "color": "#F97583" })}">var</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}"> undefined </span><span style="${ssrRenderStyle({ "color": "#F97583" })}">=</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}"> </span><span style="${ssrRenderStyle({ "color": "#9ECBFF" })}">&#39;xxx&#39;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="${ssrRenderStyle({ "color": "#D73A49" })}">var</span><span style="${ssrRenderStyle({ "color": "#24292E" })}"> undefined </span><span style="${ssrRenderStyle({ "color": "#D73A49" })}">=</span><span style="${ssrRenderStyle({ "color": "#24292E" })}"> </span><span style="${ssrRenderStyle({ "color": "#032F62" })}">&#39;xxx&#39;</span></span></code></pre></div><p>使用<strong>void 0</strong>可以避免被覆盖,从而安全地得到undefined。</p><h3 id="你了解symbol吗-它有哪些特点" tabindex="-1">你了解Symbol吗?它有哪些特点? <a class="header-anchor" href="#你了解symbol吗-它有哪些特点" aria-label="Permalink to &quot;你了解Symbol吗?它有哪些特点?&quot;">​</a></h3><p>Symbol是ES6新增的一种基本数据类型,表示独一无二的值。Symbol的特点包括:</p><p>Symbol值通过Symbol函数生成,每次调用都会返回一个唯一的值 Symbol值可以作为对象属性的标识符,防止属性名冲突 Symbol值不与其他数据进行运算,也不可与字符串拼接 for()方法可以生成同一个Symbol值 Symbol可以定义共享的常量,作为类或对象的私有属性标识</p><p>通过Symbol可以生成一个独一无二的标识符,常用于定义对象的私有属性等场景。</p><h3 id="什么是js的可迭代协议" tabindex="-1">什么是js的可迭代协议? <a class="header-anchor" href="#什么是js的可迭代协议" aria-label="Permalink to &quot;什么是js的可迭代协议?&quot;">​</a></h3><p>可迭代协议(Iterable Protocol)是ES6规定的一种约定,使得一个对象可以定义或定制它的迭代行为,也就是可以被for-of循环遍历。 具体来说,一个可迭代对象必须实现@@iterator方法,该方法返回一个带有next()方法的迭代器对象。next() 方法每次返回一个包含value和done属性的对象,这样就可以不断获取序列中的下一个值。 只要对象实现了这个协议,即可被for-of、展开语法、解构等特性调用。内置类型如Array、String都实现了可迭代协议。</p><h3 id="如何实现大文件上传" tabindex="-1">如何实现大文件上传? <a class="header-anchor" href="#如何实现大文件上传" aria-label="Permalink to &quot;如何实现大文件上传?&quot;">​</a></h3><p>实现大文件上传的方法:</p><ul><li>利用File对象的slice方法,分片切割文件</li><li>计算切片大小,一般为几MB到几十MB</li><li>在前端通过循环切片,生成多个FileBlob对象</li><li>将Blob通过FormData AJAX上传</li><li>后端收到切片后写入目标文件</li><li>所有切片上传完成,合并切片得到完整文件</li><li>这样通过分片上传可以支持大文件上传,不会消耗用户大量带宽和内存。</li></ul><h3 id="如何实现资源的懒加载" tabindex="-1">如何实现资源的懒加载? <a class="header-anchor" href="#如何实现资源的懒加载" aria-label="Permalink to &quot;如何实现资源的懒加载?&quot;">​</a></h3><p>常见的资源懒加载实现方式:</p><p>图片懒加载:判断元素进入视口才加载 基于事件或IntersectionObserver监听 动态创建script、iframe等标签异步加载 按需加载路由组件 第三方框架实现列表懒加载</p><p>核心都是判断元素进入可视区域才触发加载,减少资源占用和加载时间,提高体验。</p><h3 id="设计模式特点-要结合具体场景" tabindex="-1">设计模式特点，要结合具体场景 <a class="header-anchor" href="#设计模式特点-要结合具体场景" aria-label="Permalink to &quot;设计模式特点，要结合具体场景&quot;">​</a></h3><p>参考：</p><p>单例模式 - 系统只存在一个实例 工厂模式 - 将实例化操作委托给工厂类 适配器模式 - 转换接口适配不同对象 代理模式 - 使用代理控制对对象的访问 观察者模式 - 对象状态变化时通知其他对象 策略模式 - 封装算法使其可互换 模板方法 - 提供算法框架,延迟到子类实现 外观模式 - 提供简化的接口访问子系统</p><hr><h2 id="webpack相关" tabindex="-1">webpack相关 <a class="header-anchor" href="#webpack相关" aria-label="Permalink to &quot;webpack相关&quot;">​</a></h2><h3 id="loader和plugin的区别是什么" tabindex="-1">loader和plugin的区别是什么? <a class="header-anchor" href="#loader和plugin的区别是什么" aria-label="Permalink to &quot;loader和plugin的区别是什么?&quot;">​</a></h3><p>在webpack中,loader和plugin的区别在于:</p><p>loader主要用于转换源文件,它接收源文件并将其转换为新文件 plugin扩展了webpack的功能,在webpack运行的生命周期中注入钩子,实现比loader更广的任务</p><p>例如,loader可以转换JSX,TS,而plugin可以打包优化、资源管理、环境变量注入等。 loader转换单个文件,而plugin更强大。</p><h3 id="模块化发展历程是什么" tabindex="-1">模块化发展历程是什么? <a class="header-anchor" href="#模块化发展历程是什么" aria-label="Permalink to &quot;模块化发展历程是什么?&quot;">​</a></h3><p>JavaScript模块化发展历程经历了以下阶段:</p><ul><li>全局函数:直接定义在全局作用域,污染命名空间</li><li>IIFE模块:使用立即执行函数构建隔离作用域</li><li>CommonJS: 在服务器端实现同步加载模块</li><li>AMD: 浏览器端实现异步加载模块</li><li>CMD: CommonJS在浏览器端的实现</li><li>ES Module: 原生实现静态导入导出语法</li></ul><p>发展目标是实现可重用、松耦合的模块化开发与复用。</p><h3 id="webpack的import原理" tabindex="-1">webpack的import原理? <a class="header-anchor" href="#webpack的import原理" aria-label="Permalink to &quot;webpack的import原理?&quot;">​</a></h3><p>webpack处理import的关键步骤:</p><ol><li>解析源码,提取import依赖声明</li><li>根据依赖建立模块图谱,包含依赖关系</li><li>将所有模块放入一个code-splitting的chunks中</li><li>通过__webpack_modules__实现模块引入,__webpack_require加载模块</li><li>运行时通过jsonpInject异步注入模块代码</li></ol><p>这样webpack实现了CommonJS到浏览器端的功能映射,通过import加载模块资源。</p><h3 id="webpack如何实现动态导入" tabindex="-1">webpack如何实现动态导入? <a class="header-anchor" href="#webpack如何实现动态导入" aria-label="Permalink to &quot;webpack如何实现动态导入?&quot;">​</a></h3><p>webpack实现动态导入的方法主要有两种:</p><p>使用魔法注释语法,以注释方式声明chunkName</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="${ssrRenderStyle({ "color": "#B392F0" })}">import</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">(</span><span style="${ssrRenderStyle({ "color": "#6A737D" })}">/* webpackChunkName: &quot;chunk-name&quot; */</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}"> </span><span style="${ssrRenderStyle({ "color": "#9ECBFF" })}">&#39;./module&#39;</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="${ssrRenderStyle({ "color": "#6F42C1" })}">import</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">(</span><span style="${ssrRenderStyle({ "color": "#6A737D" })}">/* webpackChunkName: &quot;chunk-name&quot; */</span><span style="${ssrRenderStyle({ "color": "#24292E" })}"> </span><span style="${ssrRenderStyle({ "color": "#032F62" })}">&#39;./module&#39;</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">)</span></span></code></pre></div><p>在optimization选项中配置splitChunks,实现代码分割:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="${ssrRenderStyle({ "color": "#B392F0" })}">splitChunks</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">: {</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">    </span><span style="${ssrRenderStyle({ "color": "#B392F0" })}">chunks</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">: </span><span style="${ssrRenderStyle({ "color": "#9ECBFF" })}">&#39;async&#39;</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="${ssrRenderStyle({ "color": "#6F42C1" })}">splitChunks</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">: {</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#24292E" })}">    </span><span style="${ssrRenderStyle({ "color": "#6F42C1" })}">chunks</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">: </span><span style="${ssrRenderStyle({ "color": "#032F62" })}">&#39;async&#39;</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#24292E" })}">}</span></span></code></pre></div><h3 id="require和import的区别" tabindex="-1">require和import的区别? <a class="header-anchor" href="#require和import的区别" aria-label="Permalink to &quot;require和import的区别?&quot;">​</a></h3><p>require和import的主要区别有:</p><p>require是CommonJS规范,动态加载,同步执行 import是ES Module规范,编译时加载,异步执行 require是值拷贝,import模块绑定引用 require可以动态加载,import必须静态声明 两者模块缓存略有差异</p><p>因此import适合在浏览器环境下使用,可以进行Tree Shaking等优化。</p><hr><h2 id="react相关" tabindex="-1">React相关 <a class="header-anchor" href="#react相关" aria-label="Permalink to &quot;React相关&quot;">​</a></h2><ul><li>虚拟DOM和Diff算法</li><li>setState的工作原理</li><li>函数组件vs类组件</li><li>组件间通信方式</li><li>组件性能优化</li><li>React高阶组件</li><li>React Hooks的应用</li><li>组件生命周期</li><li>React路由实现</li><li>Redux状态管理</li><li>React组件测试</li></ul><p>需要重点掌握虚拟DOM、组件化、性能优化等方面</p><h3 id="什么是react的hoc" tabindex="-1">什么是React的HOC? <a class="header-anchor" href="#什么是react的hoc" aria-label="Permalink to &quot;什么是React的HOC?&quot;">​</a></h3><p>HOC(Higher-Order Component)是React的高阶组件,参数为组件,返回值为新组件的函数。 它可以像容器一样包裹组件,用于抽象和重用组件逻辑。 常用场景:</p><ul><li>权限控制</li><li>获取数据封装并传入props</li><li>修改传入的props</li></ul><p>HOC是一个reuse组件逻辑的方式,相当于组件的容器。</p><h3 id="class组件与函数组件的区别" tabindex="-1">class组件与函数组件的区别? <a class="header-anchor" href="#class组件与函数组件的区别" aria-label="Permalink to &quot;class组件与函数组件的区别?&quot;">​</a></h3><p>React中class组件和函数组件不同之处主要有:</p><ul><li>class组件有this和生命周期,函数组件通过hooks实现生命周期</li><li>class组件继承React.Component,函数组件仅为普通函数</li><li>class组件中通过state定义和管理状态,函数组件通过useState</li><li>函数组件性能更高,建议尽量使用函数组件</li></ul><p>React推荐使用函数组件代替class组件。</p><h3 id="react-hooks的优势" tabindex="-1">React hooks的优势? <a class="header-anchor" href="#react-hooks的优势" aria-label="Permalink to &quot;React hooks的优势?&quot;">​</a></h3><p>React Hooks的优势主要有:</p><ul><li>使函数组件可以使用state等特性</li><li>复用状态逻辑更方便,不用HOC或render props</li><li>分离关注点,按照语义化分离代码</li><li>更简洁易懂的代码,良好的逻辑复用</li><li>更容易编写测试用例</li><li>减少嵌套,优化组件性能</li></ul><p>Hooks解决了类组件的痛点,是函数式编程思想在React的实现。</p><h3 id="class组件与函数组件的生命周期" tabindex="-1">class组件与函数组件的生命周期? <a class="header-anchor" href="#class组件与函数组件的生命周期" aria-label="Permalink to &quot;class组件与函数组件的生命周期?&quot;">​</a></h3><p>class组件的生命周期包含挂载卸载等多个阶段,主要有:</p><ul><li>初始化阶段:constructor &gt; getDerivedStateFromProps &gt; render &gt; componentDidMount</li><li>更新阶段:getDerivedStateFromProps &gt; shouldComponentUpdate &gt; render &gt; getSnapshotBeforeUpdate &gt; componentDidUpdate</li><li>卸载阶段:componentWillUnmount</li><li>错误处理:getDerivedStateFromError &gt; componentDidCatch</li><li>函数组件通过Hooks可以模拟生命周期,常见的有:</li><li>挂载:useEffect(fn, []) 等同于 componentDidMount</li><li>更新:useEffect(fn) 等同于 componentDidUpdate</li><li>卸载:useEffect(fn, () =&gt; fn)</li><li>错误处理:useErrorHandler</li></ul><hr><h2 id="vue相关" tabindex="-1">Vue相关 <a class="header-anchor" href="#vue相关" aria-label="Permalink to &quot;Vue相关&quot;">​</a></h2><h3 id="vue2-3的区别" tabindex="-1">Vue2/3的区别? <a class="header-anchor" href="#vue2-3的区别" aria-label="Permalink to &quot;Vue2/3的区别?&quot;">​</a></h3><p>Vue2与Vue3的主要区别包括:</p><ul><li>采用Proxy代替defineProperty实现响应式</li><li>重写虚拟DOM,提升性能</li><li>Composition API代替Options API</li><li>支持Fragment、Teleport、Suspense</li><li>源码采用TypeScript重构</li><li>移除keyCode作为v-on的修饰符</li><li>...</li></ul><p>Vue3对框架进行了全面升级,性能和功能更优。</p><h3 id="vue2-项目想兼容vue3如何实现" tabindex="-1">Vue2 项目想兼容vue3如何实现? <a class="header-anchor" href="#vue2-项目想兼容vue3如何实现" aria-label="Permalink to &quot;Vue2 项目想兼容vue3如何实现?&quot;">​</a></h3><ul><li>vue-demi 库</li><li>vue2的版本升级到 2.7</li></ul><h3 id="vue的computed原理" tabindex="-1">Vue的computed原理? <a class="header-anchor" href="#vue的computed原理" aria-label="Permalink to &quot;Vue的computed原理?&quot;">​</a></h3><p>Vue中的computed实现了懒执行的缓存机制:</p><ul><li>第一次访问时会计算值并缓存</li><li>如果依赖未改变,多次访问直接返回缓存值</li><li>依赖改变时才会重新计算</li></ul><p>这样可以避免每次获取都进行高开销的计算,优化性能。</p><h3 id="为什么vue的data是个函数" tabindex="-1">为什么Vue的data是个函数? <a class="header-anchor" href="#为什么vue的data是个函数" aria-label="Permalink to &quot;为什么Vue的data是个函数?&quot;">​</a></h3><p>Vue中的data是一个对象,定义为函数返回的原因有几点:</p><ol><li>组件可能被复用,每个实例需要各自的数据副本,避免共享造成冲突</li><li>data如果以对象形式定义,那么会在多个组件实例间共享这个对象</li><li>使用函数可以使每个组件实例获得data独立的数据副本</li><li>实现了数据的私有化,每个实例可以维护一份被返回对象的独立拷贝</li></ol><p>这对实现组件数据的私有化非常重要。</p><h3 id="vue的组件通信方式" tabindex="-1">Vue的组件通信方式? <a class="header-anchor" href="#vue的组件通信方式" aria-label="Permalink to &quot;Vue的组件通信方式?&quot;">​</a></h3><p>Vue组件间常用的通信方式有:</p><ol><li>props和自定义事件:父子组件通信</li><li>provide/inject:父组件向后代注入数据</li><li>Event Bus:非父子组件间通过事件总线通信</li><li>Vuex:通过vuex module共享状态</li><li>mitt/rxjs:通过第三方pubsub库信号通信</li><li>parent/parent/parent/children:通过组件引用直接访问实例</li></ol><p>根据场景选择合适的通信方式。</p><h3 id="vue2-3的响应式原理" tabindex="-1">Vue2/3的响应式原理? <a class="header-anchor" href="#vue2-3的响应式原理" aria-label="Permalink to &quot;Vue2/3的响应式原理?&quot;">​</a></h3><p>Vue2通过Object.defineProperty()实现响应式,不能检测到数组变化和新添加的属性。 Vue3使用Proxy代替,直接代理对象实现响应式。原理有:</p><ul><li>收集依赖(track)</li><li>触发更新(trigger)</li><li>缓存(cache)</li></ul><p>Proxy可以检测数组变化和新增属性,但需要有原生支持。</p><h3 id="vue的diff算法" tabindex="-1">Vue的diff算法? <a class="header-anchor" href="#vue的diff算法" aria-label="Permalink to &quot;Vue的diff算法?&quot;">​</a></h3><p>Vue的diff主要分为三步:</p><ul><li>patch:对比新旧VNode</li><li>patchVnode:处理VNode数据变化</li><li>updateChildren:比对子节点,使用key进行高效比较</li></ul><p>优化方案:</p><ul><li>Tag不相同则直接替换</li><li>使用key唯一标识,使得复用率更高</li><li>可复用则只更新内容,不可复用则新创建</li></ul><p>这样可显著提高比较性能。</p><h3 id="nexttick的实现原理" tabindex="-1">nextTick的实现原理? <a class="header-anchor" href="#nexttick的实现原理" aria-label="Permalink to &quot;nextTick的实现原理?&quot;">​</a></h3><p>nextTick的实现原理主要是:</p><p>将回调函数加入微任务队列 等待当前任务执行完毕 清空微任务队列,执行nextTick队列 这样可以批量更新DOM,优化重排重绘。</p><h3 id="哪些css属性触发重绘重排" tabindex="-1">哪些CSS属性触发重绘重排? <a class="header-anchor" href="#哪些css属性触发重绘重排" aria-label="Permalink to &quot;哪些CSS属性触发重绘重排?&quot;">​</a></h3><p>常见触发回流的CSS属性:</p><ul><li>width / height</li><li>padding / margin</li><li>display: none;</li><li>font-size</li><li>overflow</li><li>position等影响布局的属性</li></ul><p>触发重绘的属性:</p><ul><li>color</li><li>background-color</li><li>visibility等只影响外观的属性</li></ul><p>了解区分可以避免不必要的回流影响性能。</p><h3 id="document的哪些操作触发重绘重排" tabindex="-1">document的哪些操作触发重绘重排? <a class="header-anchor" href="#document的哪些操作触发重绘重排" aria-label="Permalink to &quot;document的哪些操作触发重绘重排?&quot;">​</a></h3><p>document中的常见触发回流的操作:</p><ul><li>修改dom结构:添加/删除节点</li><li>获取计算样式:offsetTop、滚动高度</li><li>读取页面几何信息:getComputedStyle()</li><li>设置style属性值</li><li>操作class属性</li><li>读取location或offset相关数据</li><li>设置文本内容</li><li>移动/滚动元素</li><li></li></ul><p>需要注意避免频繁读取引起不必要的重排。</p><h3 id="vue生命周期的应用场景" tabindex="-1">Vue生命周期的应用场景? <a class="header-anchor" href="#vue生命周期的应用场景" aria-label="Permalink to &quot;Vue生命周期的应用场景?&quot;">​</a></h3><p>Vue生命周期函数的常见应用场景包括:</p><ul><li>beforeCreate:定义数据观察者或初始化非响应式变量</li><li>created:异步请求数据,依赖DOM的操作</li><li>mounted:访问DOM元素,绑定事件</li><li>beforeUpdate:更新之前访问现有的DOM</li><li>updated:DOM更新后执行依赖DOM的操作</li><li>beforeUnmount:解绑事件等清理任务</li><li>errorCaptured: 出错时的事件捕获处理</li></ul><p>根据需要在不同生命周期执行所需逻辑。</p><h3 id="setup的实现原理" tabindex="-1">setup的实现原理? <a class="header-anchor" href="#setup的实现原理" aria-label="Permalink to &quot;setup的实现原理?&quot;">​</a></h3><p>Vue3中的setup实现原理:</p><ul><li>创建一个新的 Proxy 代理对象作为响应式上下文</li><li>将props解构传入上下文,统计依赖</li><li>执行setup函数,返回函数或对象</li><li>将setup返回值挂载到render上下文</li><li>effect自动收集依赖,trigger触发响应</li><li>setup为组件提供了统一的响应式编程模型。</li></ul><hr><h2 id="浏览器相关" tabindex="-1">浏览器相关 <a class="header-anchor" href="#浏览器相关" aria-label="Permalink to &quot;浏览器相关&quot;">​</a></h2><h3 id="chrome的samesite属性了解吗" tabindex="-1">Chrome的samesite属性了解吗? <a class="header-anchor" href="#chrome的samesite属性了解吗" aria-label="Permalink to &quot;Chrome的samesite属性了解吗?&quot;">​</a></h3><p>SameSite是一个Cookie的属性,用来提供第三方Cookie的跨站限制,主要作用是防止CSRF攻击。 它有两种模式:</p><p>None:默认,跨站设置Cookie Lax:大多数请求允许跨站Cookie Strict:禁止第三方Cookie,只在同站设置和发送</p><p>Chrome最近在SameSite上有更新,开发者需要注意跨域请求所依赖的Cookie设置。</p><h3 id="fetch-和-ajax、axios、request-请求的区别" tabindex="-1">fetch 和 ajax、axios、request 请求的区别？ <a class="header-anchor" href="#fetch-和-ajax、axios、request-请求的区别" aria-label="Permalink to &quot;fetch 和 ajax、axios、request 请求的区别？&quot;">​</a></h3><p>-- 回答重点：XmlHttpRequest 是浏览器提供的与后端交互的普通对象，ajax 是基于 XmlHttpRequest 封装实现的，fetch 同样是由浏览器提供的，但是fetch返回的是一个Promise对象，且 fetch 请求相比之下更加简单，功能相对单一，fetch 请求不可中断，只能前端忽略(即 fetch请求一旦发起后端必然会接收到，只能通过AbortController做到前端忽略后端给到的反馈而已)；而 axios 是也是基于 XmlHttpRequest 的二次封装，只是结合了ES6的Promise，可以让代码更好用，request的话就是nodejs的了，属于后端的基于http请求进行封装的</p><h3 id="浏览器的最大请求并发数" tabindex="-1">浏览器的最大请求并发数？ <a class="header-anchor" href="#浏览器的最大请求并发数" aria-label="Permalink to &quot;浏览器的最大请求并发数？&quot;">​</a></h3><p>如何优化过多的并发请求？ --回答提示：使用http1协议的情况下，chrome浏览器对于同一个域名的请求资源最大为6个，当使用http2.0的情况下，同一个TCP连接上可以发送无限多个请求，自然也就无关无关浏览器的这种限制了</p><h3 id="限制请求资源个数的原因" tabindex="-1">限制请求资源个数的原因? <a class="header-anchor" href="#限制请求资源个数的原因" aria-label="Permalink to &quot;限制请求资源个数的原因?&quot;">​</a></h3><p>使用 HTTP/1.x 协议,浏览器同一时间对于同一域名的资源请求数量是有限制的,最大允许6个。 限制请求资源个数主要出于以下考虑:</p><p>浏览器处理请求和响应的线程数有限 预防DDOS攻击 防止某一个域名独占所有的tcp连接数</p><p>所以对资源请求数量进行了限制。</p><h3 id="http2如何解决请求资源限制" tabindex="-1">http2如何解决请求资源限制? <a class="header-anchor" href="#http2如何解决请求资源限制" aria-label="Permalink to &quot;http2如何解决请求资源限制?&quot;">​</a></h3><p>HTTP/2协议使用了多路复用机制,在一个TCP连接上可以并行交错的传输多份请求和响应数据。</p><p>一条连接上的多数据流可以互不干扰 二进制分帧减少协议开销 服务端推送机制 头部压缩节省带宽</p><p>这样就不存在明显的请求数限制,并发请求和资源下载更加高效。</p><h3 id="https-对比-http" tabindex="-1">https 对比 http? <a class="header-anchor" href="#https-对比-http" aria-label="Permalink to &quot;https 对比 http?&quot;">​</a></h3><p>-- todo</p><h3 id="浏览器存储方式有哪些" tabindex="-1">浏览器存储方式有哪些? <a class="header-anchor" href="#浏览器存储方式有哪些" aria-label="Permalink to &quot;浏览器存储方式有哪些?&quot;">​</a></h3><p>常见的浏览器存储方式包括:</p><ul><li>Cookie:存储少量数据,每次请求都会发送到服务器</li><li>LocalStorage:键值对存储,存储在客户端,容量较大,不会自动发送到服务器</li><li>SessionStorage:与LocalStorage类似,但数据只存在于当前会话,窗口或标签关闭则清空</li><li>IndexedDB:键值对存储,可以存储结构化克隆对象,大容量存储</li><li>Cache API:缓存请求或其他数据,作用域为窗口或者服务工作器</li><li>WebSQL:基于SQL的关系型数据库,已不推荐使用</li></ul><p>根据需要选择合适的浏览器存储方式。</p><h3 id="session、cookie、sessionstorage的区别" tabindex="-1">session、cookie、sessionStorage的区别? <a class="header-anchor" href="#session、cookie、sessionstorage的区别" aria-label="Permalink to &quot;session、cookie、sessionStorage的区别?&quot;">​</a></h3><p>session、cookie和sessionStorage的区别主要在:</p><p><strong>作用域:</strong> cookie可跨域名,其他两者当前源限制<br><strong>生命周期</strong> :cookie可设置过期时间,sessionStorage对应session,关闭则清空<br><strong>存储大小:</strong> cookie 4kb左右,sessionStorage约5MB,localStorage更大<br><strong>请求发送:</strong> cookie会自动发送,后两者仅在客户端<br><strong>用途:</strong> cookie常用于存储用户信息,localStorage用于持久保存数据<br><strong>API访问:</strong> cookie直接document.cookie,后两者直接localStorage对象</p><p>根据实际需要选择合适的浏览器存储方式。</p><h3 id="如何监听页面关闭事件" tabindex="-1">如何监听页面关闭事件? <a class="header-anchor" href="#如何监听页面关闭事件" aria-label="Permalink to &quot;如何监听页面关闭事件?&quot;">​</a></h3><p>常用的页面关闭事件监听方式:</p><ul><li>window.onbeforeunload,页面关闭前执行</li><li>window.onunload,页面完全卸载时</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">document.</span><span style="${ssrRenderStyle({ "color": "#B392F0" })}">addEventListener</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">(</span><span style="${ssrRenderStyle({ "color": "#9ECBFF" })}">&#39;visibilitychange&#39;</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">, fn) </span><span style="${ssrRenderStyle({ "color": "#6A737D" })}">//监听visibilityState</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="${ssrRenderStyle({ "color": "#24292E" })}">document.</span><span style="${ssrRenderStyle({ "color": "#6F42C1" })}">addEventListener</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">(</span><span style="${ssrRenderStyle({ "color": "#032F62" })}">&#39;visibilitychange&#39;</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">, fn) </span><span style="${ssrRenderStyle({ "color": "#6A737D" })}">//监听visibilityState</span></span></code></pre></div><p>或者结合pagehide等事件判断页面状态。 需要注意浏览器兼容性问题,跨浏览器支持比较复杂。</p><h3 id="浏览器的跨页签数据共享方案" tabindex="-1">浏览器的跨页签数据共享方案? <a class="header-anchor" href="#浏览器的跨页签数据共享方案" aria-label="Permalink to &quot;浏览器的跨页签数据共享方案?&quot;">​</a></h3><p>浏览器跨页面签数据共享的实现方式:</p><ul><li>localStorage 或 IndexedDB存储数据,不同页签可共享</li><li>Broadcast Channel API,用于页面间通信</li><li>Service Worker 也可以用于数据共享</li><li>父级域名设置cookie,页面可共享读取</li><li>Location Hash 也可进行有限数据共享</li></ul><p>可以根据需要选择合适的跨页签数据共享方案。</p><hr><h2 id="浏览器性能优化相关" tabindex="-1">浏览器性能优化相关 <a class="header-anchor" href="#浏览器性能优化相关" aria-label="Permalink to &quot;浏览器性能优化相关&quot;">​</a></h2><h3 id="chrome性能测试里的关键参数有哪些" tabindex="-1">chrome性能测试里的关键参数有哪些? <a class="header-anchor" href="#chrome性能测试里的关键参数有哪些" aria-label="Permalink to &quot;chrome性能测试里的关键参数有哪些?&quot;">​</a></h3><p>Chrome性能面板常看的关键指标:</p><ul><li>FPS: 动画或滚动时每个帧的耗时,越高越好</li><li>CPU:各个事件所占用的CPU时间</li><li>NETWORK:页面资源加载时间等网络指标</li><li>HEAP:内存占用及泄漏相关</li><li>JS PROFILE: hot path 等 JS执行分析</li></ul><p>这些指标可以分析页面的渲染、加载、资源、内存等性能。 一个网站打开页面卡顿的常见问题有哪些?举例说明几个,并说明下常用的解决方案</p><p>页面卡顿的常见原因:</p><ul><li>图片未压缩,资源体积太大</li><li>CSS/JS文件体积过大</li><li>重复DOM操作引起频繁重排重绘</li><li>内存泄漏导致频繁GC</li><li>频繁网络请求阻塞页面</li></ul><p>解决方案:</p><ul><li>代码优化,减少DOM操作</li><li>图片懒加载</li><li>避免大体积资源导致主线程阻塞</li><li>合理使用web worker分离线程</li><li>预编译、缓存等手段</li></ul><p>需要定位具体原因进行有针对性优化。</p><h3 id="类似一个官网页面向下滚动时画面卡顿的情况遇到过吗-这种卡顿情况一般可能是什么问题导致的-又该怎么优化呢" tabindex="-1">类似一个官网页面向下滚动时画面卡顿的情况遇到过吗?这种卡顿情况一般可能是什么问题导致的?又该怎么优化呢? <a class="header-anchor" href="#类似一个官网页面向下滚动时画面卡顿的情况遇到过吗-这种卡顿情况一般可能是什么问题导致的-又该怎么优化呢" aria-label="Permalink to &quot;类似一个官网页面向下滚动时画面卡顿的情况遇到过吗?这种卡顿情况一般可能是什么问题导致的?又该怎么优化呢?&quot;">​</a></h3><p>页面滚动卡顿的原因:</p><ul><li>重绘重排频繁导致计算过慢</li><li>渲染区域过多节点,需要大量计算样式</li><li>触发频繁的GPU合成</li></ul><p>解决方式:</p><ul><li>optimize-css-assets-webpack-plugin压缩css</li><li>shouldComponentUpdate优化渲染</li><li>减少不必要的重排重绘</li><li>避免过深DOM树</li><li>使用will-change提示浏览器提前合成层</li></ul><p>主要还是需要定位优化重绘重排和页面合成。</p><hr><h2 id="前端架构相关" tabindex="-1">前端架构相关 <a class="header-anchor" href="#前端架构相关" aria-label="Permalink to &quot;前端架构相关&quot;">​</a></h2><h3 id="前端的单元测试有写过吗-有哪些单元测试框架-vue2-3、react的相关单测框架" tabindex="-1">前端的单元测试有写过吗?有哪些单元测试框架(vue2/3、react的相关单测框架) <a class="header-anchor" href="#前端的单元测试有写过吗-有哪些单元测试框架-vue2-3、react的相关单测框架" aria-label="Permalink to &quot;前端的单元测试有写过吗?有哪些单元测试框架(vue2/3、react的相关单测框架)&quot;">​</a></h3><p>常用的前端单元测试框架包括:</p><ul><li>Jest: Facebook出品,适合React应用</li><li>Mocha: 简单灵活,搭配Chai使用</li><li>Jasmine: 语法简单清晰的BDD框架</li><li>Karma: 运行测试用例的Test Runner</li><li>Cypress: 端到端测试框架</li><li>puppeteer: Headless Chrome测试</li><li></li></ul><p>可以根据具体项目需求选择合适的框架。</p><h3 id="前端安全问题有哪些" tabindex="-1">前端安全问题有哪些? <a class="header-anchor" href="#前端安全问题有哪些" aria-label="Permalink to &quot;前端安全问题有哪些?&quot;">​</a></h3><p>前端常见的安全问题包括:</p><ul><li>XSS攻击:注入恶意脚本,盗取信息</li><li>CSRF攻击:跨站请求伪造攻击</li><li>点击劫持:修改链接地址欺骗用户</li><li>暴露信息:如抓包获得敏感信息</li><li>中间人攻击:插入非法代理截获用户信息</li><li></li></ul><p>需要对用户输入输出进行校验, token验证身份, HTTPS传输, 代码混淆加密等来保证安全。</p><h3 id="首屏-ssr-有了解吗" tabindex="-1">首屏 SSR 有了解吗? <a class="header-anchor" href="#首屏-ssr-有了解吗" aria-label="Permalink to &quot;首屏 SSR 有了解吗?&quot;">​</a></h3><p>SSR即服务器端渲染,是一种使网站内容在服务器端渲染成静态HTML字符串,再发送给客户端的技术。 其工作流程是:</p><ol><li>服务器接受请求,交给对应的路由处理</li><li>路由根据当前URL返回需要渲染的组件</li><li>在服务器使用VDOM生成组件静态HTML字符串</li><li>将HTML发送给客户端,客户端接收并显示</li><li>SSR可以有效改善SEO并加快首屏加载速度。</li></ol><h3 id="nuxt3-和-nextjs-在-ssr-实现架构上有什么区别-简要举例说明一下" tabindex="-1">Nuxt3 和 NextJs 在 SSR 实现架构上有什么区别?简要举例说明一下 <a class="header-anchor" href="#nuxt3-和-nextjs-在-ssr-实现架构上有什么区别-简要举例说明一下" aria-label="Permalink to &quot;Nuxt3 和 NextJs 在 SSR 实现架构上有什么区别?简要举例说明一下&quot;">​</a></h3><p>Nuxt3和Nextjs在SSR实现上的主要区别有:</p><ul><li>Next直接输出HTML字符串,Nuxt通过vue-server-renderer节点流生成</li><li>Nuxt使用异步组件加载,Next所有路由组件同步加载</li><li>Next链接跳转采用客户端路由,Nuxt为服务端路由</li><li>Nuxt支持安全的异步数据获取,Next需要getInitialProps</li><li>Nuxt基于Vue的组件树,Next基于React组件</li></ul><p>两者都非常成熟,可以根据需求灵活选择。</p><h3 id="什么是restful-api-其规定了哪些请求类型" tabindex="-1">什么是Restful API,其规定了哪些请求类型? <a class="header-anchor" href="#什么是restful-api-其规定了哪些请求类型" aria-label="Permalink to &quot;什么是Restful API,其规定了哪些请求类型?&quot;">​</a></h3><p>RESTful API是一种流行的API设计理念和规范,主要原则包括:</p><ul><li>每个URI代表一种资源</li><li>客户端使用GET、POST、PUT等动词对资源进行操作</li><li>不会在URI中包含动作,全在HTTP头指定</li><li>返回JSON或XML格式数据</li></ul><p>RESTful设计的API有良好的可见性和可扩展性。</p><h3 id="没有没做过埋点-了解或用过哪些埋点框架-有实际经验的话-举例说明一个埋点方案" tabindex="-1">没有没做过埋点?了解或用过哪些埋点框架?有实际经验的话,举例说明一个埋点方案 <a class="header-anchor" href="#没有没做过埋点-了解或用过哪些埋点框架-有实际经验的话-举例说明一个埋点方案" aria-label="Permalink to &quot;没有没做过埋点?了解或用过哪些埋点框架?有实际经验的话,举例说明一个埋点方案&quot;">​</a></h3><p>常见的前端埋点框架包括:</p><ul><li>Google Tag Manager:谷歌提供,无埋点,易扩展</li><li>友盟:功能全面,使用简单的埋点UI设计</li><li>GrowingIO:提供debugger工具,支持全埋点和无埋点</li><li>TalkingData:码则式埋点,灵活但需要自行组合</li><li>听云:SDK接入自动采集,提供可视化界面</li></ul><p>可以根据需求选择合适的埋点框架。</p><h3 id="团队开发过程中我们需要设定些什么规范来确保协同开发" tabindex="-1">团队开发过程中我们需要设定些什么规范来确保协同开发? <a class="header-anchor" href="#团队开发过程中我们需要设定些什么规范来确保协同开发" aria-label="Permalink to &quot;团队开发过程中我们需要设定些什么规范来确保协同开发?&quot;">​</a></h3><p>组织团队协同开发常用的方式:</p><ul><li>制定代码及提交规范,如commit message准则等</li><li>代码Review,合并请求审阅制度确保代码质量</li><li>定期站会沟通开发进度和技术细节</li><li>按功能模块划分开发任务,并明确负责人</li><li>建立协同开发流程,如git-flow分支策略</li><li>建立技术选型评审机制,重要选择通过讨论决定</li><li>建立unittest 和测试环境,以保证主流程稳定</li></ul><h2 id="业务相关" tabindex="-1">业务相关 <a class="header-anchor" href="#业务相关" aria-label="Permalink to &quot;业务相关&quot;">​</a></h2><h3 id="用户登录凭证失败之后会发生什么" tabindex="-1">用户登录凭证失败之后会发生什么？ <a class="header-anchor" href="#用户登录凭证失败之后会发生什么" aria-label="Permalink to &quot;用户登录凭证失败之后会发生什么？&quot;">​</a></h3><p>-- 回答重点：提示给用户失败原因，并重定向到登录页（这里不同的登录方案有不同的处理方式，单点登录、无感登录、OAuth2.0需要去了解一下）</p><h3 id="单点登录、无感登录、oauth2-0有了解吗-简要说明一下" tabindex="-1">单点登录、无感登录、OAuth2.0有了解吗？简要说明一下 <a class="header-anchor" href="#单点登录、无感登录、oauth2-0有了解吗-简要说明一下" aria-label="Permalink to &quot;单点登录、无感登录、OAuth2.0有了解吗？简要说明一下&quot;">​</a></h3><h3 id="前端如何拿到用户的-openid-对-oauth-协议的了解说明一下" tabindex="-1">前端如何拿到用户的 openId，对 OAuth 协议的了解说明一下 <a class="header-anchor" href="#前端如何拿到用户的-openid-对-oauth-协议的了解说明一下" aria-label="Permalink to &quot;前端如何拿到用户的 openId，对 OAuth 协议的了解说明一下&quot;">​</a></h3><h2 id="实际项目相关" tabindex="-1">实际项目相关 <a class="header-anchor" href="#实际项目相关" aria-label="Permalink to &quot;实际项目相关&quot;">​</a></h2><h3 id="团队开发过程中我们需要设定些什么规范来确保协同开发-1" tabindex="-1">团队开发过程中我们需要设定些什么规范来确保协同开发？ <a class="header-anchor" href="#团队开发过程中我们需要设定些什么规范来确保协同开发-1" aria-label="Permalink to &quot;团队开发过程中我们需要设定些什么规范来确保协同开发？&quot;">​</a></h3><p>回答提及这些：提交规范(git flow)，分支策略，review，CICD代码质量检查、隐私安全扫描等</p></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("interview/questions/常见的基础题.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const ______ = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  ______ as default
};
