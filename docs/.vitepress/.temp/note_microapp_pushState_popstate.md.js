import { ssrRenderAttrs, ssrRenderStyle } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.cc2b3d55.js";
const __pageData = JSON.parse('{"title":"history之popState和pushState","description":"","frontmatter":{"title":"history之popState和pushState","date":"2023-09-14T00:00:00.000Z"},"headers":[],"relativePath":"note/microapp/pushState&popstate.md","filePath":"note/microapp/pushState&popstate.md","lastUpdated":1708996912000}');
const _sfc_main = { name: "note/microapp/pushState&popstate.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="history之popstate和pushstate" tabindex="-1">history之popState和pushState <a class="header-anchor" href="#history之popstate和pushstate" aria-label="Permalink to &quot;history之popState和pushState&quot;">​</a></h1><h1 id="history" tabindex="-1">history <a class="header-anchor" href="#history" aria-label="Permalink to &quot;history&quot;">​</a></h1><blockquote><p>window.history是只读属性。</p></blockquote><p>使用 history.pushState() 可以改变referrer，它在用户发送XMLHttpRequest请求时在HTTP头部使用，改变state后创建的XMLHttpRequest对象的referrer都会被改变。因为referrer是标识创建XMLHttpRequest对象时 this 所代表的window对象中document的URL。</p><ul><li>pushState()存储当前历史记录点，</li><li>replaceState()替换当前历史记录点</li><li>popstate监听当前历史记录点。-onpopstate</li></ul><h2 id="pushstate" tabindex="-1">pushState <a class="header-anchor" href="#pushstate" aria-label="Permalink to &quot;pushState&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">history.</span><span style="${ssrRenderStyle({ "color": "#B392F0" })}">pushState</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">(stateObject, title, </span><span style="${ssrRenderStyle({ "color": "#79B8FF" })}">URL</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="${ssrRenderStyle({ "color": "#24292E" })}">history.</span><span style="${ssrRenderStyle({ "color": "#6F42C1" })}">pushState</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">(stateObject, title, </span><span style="${ssrRenderStyle({ "color": "#005CC5" })}">URL</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">);</span></span></code></pre></div><p>pushState方法可以在不刷新页面的情况下，改变页面的URL，这样就可以实现前端路由的效果。</p><p>该方法将新的状态（state）压入浏览器历史记录栈，并且更新页面的URL。该方法接收三个参数：</p><ul><li>stateObject：表示新压入的状态对象，可以是任何JavaScript对象。</li><li>title：新页面的标题，一般传递一个空字符串即可。</li><li>URL：表示新页面的URL地址。</li></ul><p>该方法用于监听浏览器的历史记录改变事件，并执行相关的处理。当用户点击浏览器的后退或前进按钮时，就会触发该事件。在事件处理函数中，可以根据event.state属性获取到当前的历史状态，从而进行相应的处理。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">window.</span><span style="${ssrRenderStyle({ "color": "#B392F0" })}">addEventListener</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">(</span><span style="${ssrRenderStyle({ "color": "#9ECBFF" })}">&quot;popstate&quot;</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">, </span><span style="${ssrRenderStyle({ "color": "#F97583" })}">function</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">(</span><span style="${ssrRenderStyle({ "color": "#FFAB70" })}">event</span><span style="${ssrRenderStyle({ "color": "#E1E4E8" })}">) { </span><span style="${ssrRenderStyle({ "color": "#6A737D" })}">// 处理历史记录改变事件 });</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="${ssrRenderStyle({ "color": "#24292E" })}">window.</span><span style="${ssrRenderStyle({ "color": "#6F42C1" })}">addEventListener</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">(</span><span style="${ssrRenderStyle({ "color": "#032F62" })}">&quot;popstate&quot;</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">, </span><span style="${ssrRenderStyle({ "color": "#D73A49" })}">function</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">(</span><span style="${ssrRenderStyle({ "color": "#E36209" })}">event</span><span style="${ssrRenderStyle({ "color": "#24292E" })}">) { </span><span style="${ssrRenderStyle({ "color": "#6A737D" })}">// 处理历史记录改变事件 });</span></span></code></pre></div><h2 id="replacestate" tabindex="-1">replaceState <a class="header-anchor" href="#replacestate" aria-label="Permalink to &quot;replaceState&quot;">​</a></h2><p>replaceState是对当前状态对象的修改</p><p>replaceState(state, title, url)</p></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("note/microapp/pushState&popstate.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const pushState_popstate = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  pushState_popstate as default
};
