---
isTimeLine: true
title: 垃圾回收机制
date: 2021-11-21
tags:
- todo
---
# 垃圾回收机制

> 垃圾回收是一种自动的内存管理机制。当计算机上的动态内存不再需要时，就应该予以释放。

> 需要注意的是，自动的意思是浏览器可以自动帮助我们回收内存垃圾，但并不代表我们不用关心内存管理，如果操作不当，JavaScript中仍然会出现内存溢出的情况，造成系统崩溃。

标记清除，引用计数

## 问什么是垃圾

一般来说没有被引用的对象就是垃圾，就是要被清除.


## 标记-清除法

> JavaScript中最常用的垃圾回收方式

* 垃圾回收器获取根并**“标记”**(记住)它们。
* 然后它访问并“标记”所有来自它们的引用。
* 然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。
* 以此类推，直到有未访问的引用(可以从根访问)为止。
* 除标记的对象外，所有对象都被删除。


**-- 分为两个阶段 标记阶段 、 清除阶段**

标记阶段： JavaScript中有一个全局对象，定期的，垃圾回收器将从这个全局对象开始，找出所有从这个全局对象开始引用的对象，再找这些对象引用的对象，然后对这些活跃的对象标记
清除阶段：清除那些没有被标记的对象

**补充**

标记阶段引入： **三色标记法**；

* 白：未被标记的对象，即不可达对象（没有扫描到的对象），可回收
* 灰：已被标记的对象（可达对象），但是对象还没有被扫描完，不可回收
* 黑：已被扫描完（可达对象），不可回收

**清除之后引发的问题**

清除之后，内存空间变为不连续的（内存碎片），后续如果有大的连续的内存空间无法使用，需要进行**标记整理**将内存变为连续的


一些优化:

* 分代回收——对象分为两组:“新对象”和“旧对象”。许多对象出现，完成它们的工作并迅速结 ，它们很快就会被清理干净。那些活得足够久的对象，会变“老”，并且很少接受检查。
* 增量回收——如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分。然后，各个部分分别执行。这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。
* 空闲时间收集——垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。

## 引用计数法

> 引用计数的含义是跟踪记录每个值被引用的次数。当一个变量A被赋值时，这个值的引用次数就是1，当变量A重新赋值后，则之前那个值的引用次数就减1。当引用次数变成0时，则说明没有办法再访问这个值了，所以就可以清除这个值占用的内存了。

如果存在循环引用的情况，计数可能不为0，因此无法清除，**大多数浏览器已经放弃了这种方法**。


## 参考

[前端面试：谈谈 JS 垃圾回收机制](https://juejin.cn/post/6844903810603679751)

[几种垃圾回收算法](https://www.jianshu.com/p/a8a04fd00c3c)

[[译] JavaScript如何工作：垃圾回收机制 + 常见的4种内存泄漏](https://juejin.cn/post/6844903810825994253)
