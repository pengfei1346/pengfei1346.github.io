<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>

<script>

    // let compose = (...fns) => {
    //     // 取出第一个函数，当做reduce函数的初始值
    //     // const init = fns.shift();
    //     // return function(...arg) {
    //     //     // 执行compose函数，返回一个函数
    //     //     return fns.reduce(
    //     //         (pre, cur) => {
    //     //             // 返回list.reduce的结果，为一个promise实例，外部就可以通过then获取
    //     //             return pre.then(result => {
    //     //                 // pre始终为一个promise实例，result为结果的累加值
    //     //                 // 在前一个函数的then中，执行当前的函数，并返回一个promise实例，实现累加传递的效果
    //     //                 return cur.call(null, result);
    //     //             });
    //     //         },
    //     //         // Promise.resolve可以将非promise实例转为promise实例（一种兼容处理）
    //     //         Promise.resolve(init.apply(null, arg))
    //     //     );
    //     // };
    //
    //     // return fns.reduce((a, b) => (...args) => a(b(...args)))
    //     return fns.reduce((pre,cur) => (...args) => pre(cur(...args)))
    //
    // }
    //
    // const add = x => x + 10;
    // const multiply = x => x * 10;
    //
    // const calculate = compose(multiply,add)
    // // console.log(calculate(10));
    //
    //
    // // return Object.prototype.toString.call(data).slice(8,-1).toLocaleUpperCase()
    //
    //
    // class Scheduler {
    //     constructor() {
    //         this.queue = [];
    //         this.maxCount = 2;
    //         this.runCounts = 0;
    //     }
    //     add(promiseCreator) {
    //         this.queue.push(promiseCreator);
    //     }
    //     taskStart() {
    //         for (let i = 0; i < this.maxCount; i++) {
    //             this.request();
    //         }
    //     }
    //     request() {
    //         if (!this.queue || !this.queue.length || this.runCounts >= this.maxCount) {
    //             return;
    //         }
    //         this.runCounts++;
    //
    //         this.queue.shift()().then(() => {
    //             this.runCounts--;
    //             this.request();
    //         });
    //     }
    // }
    //
    // const timeout = time => new Promise(resolve => {
    //     setTimeout(resolve, time);
    // })
    //
    // const scheduler = new Scheduler();
    //
    // const addTask = (time,order) => {
    //     scheduler.add(() => timeout(time).then(()=>console.log(order)))
    // }


    // addTask(1000, '1');
    // addTask(500, '2');
    // addTask(300, '3');
    // addTask(400, '4');
    // scheduler.taskStart()

    // window.name = 'bytedance';
    // function A() {
    //     this.name = '123';
    // }
    // A.prototype.getA = function() {
    //     console.log(this);
    //     return this.name + 1;
    // }
    // let a = new A();
    // let funcA = a.getA;
    // funcA()


    // window.name = 'bytedance';
    // class A{
    //     constructor() {
    //         this.name = '123';
    //     }
    //     getA() {
    //         console.log(this);
    //         return this.name + 1;
    //     }
    // }
    // let a = new A();
    // let funcA = a.getA;
    // funcA();

    // let a = 10
    // const b = 20
    // function foo () {
    //     var a = 30
    //
    //     console.log(this.a)  // undefined
    //     console.log(this.b)  // undefined
    // }
    // foo();
    // console.log(window.a) // undefined


    // 两数之和

    //
    // var twoSum = function(nums, target) {
    //
    //     let map = {}
    //
    //     for (let i = 0; i < nums.length; i++) {
    //
    //         let curTarget = target - nums[i]
    //
    //         if(map[curTarget] !== undefined) {
    //             return [i,map[curTarget]]
    //         }
    //
    //         map[nums[i]] = i
    //     }
    //
    //
    // };
    //
    // // console.log(twoSum([1,2,5,6,7],11));
    //
    //
    // /**
    //  * @param {number} x
    //  * @return {number}
    //  */
    // var reverse = function(x) {
    //     let result = 0;
    //     while(x !== 0) {
    //         result = result * 10 + x % 10;
    //         x = Math.floor(x / 10) | 0;
    //     }
    //     return (result | 0) === result ? result : 0;
    // };
    //
    //
    // console.log(reverse(123));

    // const Foo = (function () {
    //     let idIndex = 1
    //     return function () {
    //         console.log();
    //         if(!this instanceof Foo) {
    //             this.id = idIndex++
    //         }else {
    //             return {
    //                 id: idIndex++
    //             }
    //         }
    //     }
    // })()
    //
    // let a = new Foo()
    // let b = Foo()
    // console.log(b);




    //40. 判断一个字符串是否是回文字符串？


    // flat
    // function flat(arr) {
    //     // let str = arr.toString().replaceAll('[','').replaceAll(']','')
    //     // return str.split(',')
    //
    //     // return arr.flat(Infinity)
    //
    //     // return arr.reduce( (pre,cur) => {
    //     //     Array.isArray(cur)?pre.push(...cur):pre.push(cur)
    //     //     return pre
    //     // },[])
    // }

    // console.log(flat([1, 2, [3, 4], [5, 6], 7]));

    // 37. 数字千分位格式化问题

    // 34. 无重复字符的最长子串

    // function maxLenth(s) {
    //     if(!s) return 0;
    //     let left = 0,right = 0;
    //     let maxLen = 0;
    //     const map = new Map();
    //     while(right < s.length) {
    //         if(map.has(s[right]) && (map.get(s[right]) + 1 > left)) {
    //             left = map.get(s[right]) + 1;
    //         }
    //         map.set(s[right], right);
    //         maxLen = Math.max(maxLen, right - left + 1);
    //         right ++;
    //     }
    //     return maxLen;
    // }
    //
    // // console.log(maxLenth('abcabcbb'));
    // // "abcabcbb" => 3   "bbbbb"=>1   "pwwkew"=>3
    //
    // var length = 10;
    // function fn() {
    //     return this.length + 1;
    // }
    // var obj = {
    //     length: 5,
    //     test1: function() {
    //         return fn();
    //     }
    // }
    // obj.test2 = fn;
    //
    // // console.log(obj.test2(1));
    // // console.log(fn() === obj.test2())
    //
    //
    //
    // ////////////////
    // var a = function () {
    //     // console.log(this);
    //     // this指向window 其实修改的是 window.b
    //     this.b = 3;
    // }
    //
    // var c= new a();
    //
    // a.prototype.b = 9;
    //
    // // var声明的是全局变量 = window.b = 7
    // var b = 7;
    //
    // a();
    //
    // console.log(b);
    // console.log(c.b)


    // 27. css3实现多行文字截断处理
    //     // 单行
    //     .oneline {
    //     overflow: hidden;
    //     text-overflow: ellipsis;
    //     white-space: nowrap;
    // }
    // // 多行
    // .multiple-line {
    //     display: -webkit-box;
    //     overflow: hidden;
    //     -webkit-line-clamp: {行数};
    //     -webkit-box-orient: vertical;
    // }



    // // 需要实现的函数
    // function repeat(func, times, wait) {
    //     return function(str) {
    //         for(let i=0;i<times;i++) {
    //             setTimeout(() => {
    //                 func(str)
    //             }, i * wait)
    //         }
    //     }
    // }

    // 使下面调用能正常工作
    // const repeatFunc = repeat(console.log, 4,3000);
    // repeatFunc('hello world'); // 会输出4次 hellow world 每次间隔3s


    // function selfNew(fn, ...args) {
    //     // 创建一个新对象，该对象的原型是fn.prototype
    //     let newObj = Object.create(fn.prototype);
    //     // 调用构造函数，使用apply，将this指向新生成的对象
    //     let result = fn.apply(newObj, args);
    //
    //     // 如果fn函数有返回值，并且返回值是一个对象或方法，则返回该对象，否则返回新生成的instance对象
    //     // return typeof res === "object" || typeof res === "function" ? res : instance;
    //
    //     return result instanceof Object ? result : newObj
    //
    // }
    //
    //
    // function Dog(name) {
    //     this.name = name;
    //     return { test: 1 };
    // }
    // let obj1 = selfNew(Dog,"ming");
    // console.log(obj1); // {test:1}




    // 异步并发- js实现一个带并发限制的一部调度器，保证同时运行的任务最多有两个

    // class Scheduler {
    //     constructor() {
    //         this.queue = []
    //     }
    //     add(promiseCreator) {
    //         this.queue.push(promiseCreator)
    //     }
    // }
    //
    // const timeout = time => new Promise(resolve => {
    //     setTimeout(resolve, time);
    // })
    //
    // const scheduler = new Scheduler();
    // const addTask = (time, order) => {
    //     scheduler.add(() => timeout(time)).then(() => console.log(order))
    // }

    // addTask(1000, '1')
    // addTask(500, '2')
    // addTask(300, '3')
    // addTask(400, '4')

    // function inherit(Son, Father) {
    //     const prototype = Object.create(Father.prototype) // 获取父类原型对象副本
    //     prototype.constructor = Son // 将获取的副本的constructor指向子类，以此增强副本原型对象
    //     Son.prototype = prototype // 将子类的原型对象指向副本原型对象
    // }

    //
    // //Person构造函数
    // function Person(){
    // }
    // //示例
    // //方式一：通过new方法来创建实例
    // //方式二：通过.creat方法来创建示例
    // var person2 = Object.create(Person)
    // var person3 = Object.create(Person.prototype)
    // console.log('person2 instanceof Person:',person2 instanceof Person);
    // console.log('person3 instanceof Person:',person3 instanceof Person);
    //
    //
    //
    // // 寄生
    // function inherit(Son, Father) {
    //     const prototype = Object.create(Father.prototype) // 获取父类原型对象副本
    //     prototype.constructor = Son // 将获取的副本的constructor指向子类，以此增强副本原型对象
    //     Son.prototype = prototype // 将子类的原型对象指向副本原型对象
    // }



    // a == 1 && a == 2 && a == 3
    //

    Promise.resolve()
        .then(function() {
            console.log("promise0");
        })
        .then(function() {
            console.log("promise5");
        });
    setTimeout(() => {
        console.log("timer1");
        Promise.resolve().then(function() {
            console.log("promise2");
        });
        Promise.resolve().then(function() {
            console.log("promise4");
        });
    }, 0);
    setTimeout(() => {
        console.log("timer2");
        Promise.resolve().then(function() {
            console.log("promise3");
        });
    }, 0);
    Promise.resolve().then(function() {
        console.log("promise1");
    });
    console.log("start");

    // 打印结果： start promise0 promise1 promise5 timer1 promise2 promise4 timer2 promise3






























</script>

</html>
